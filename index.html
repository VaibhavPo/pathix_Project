<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pathix</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/konva@9.2.0/konva.min.js"></script>
  <style>
    :root {
      --bg-gradient: linear-gradient(135deg, #232946 0%, #181c2a 100%);
      --glass-bg: rgba(36, 41, 61, 0.65);
      --glass-border: rgba(255,255,255,0.12);
      --glass-blur: 18px;
      --primary: #a3bffa;
      --accent: #f6c177;
      --button-glow: 0 0 16px #f6c17788, 0 2px 8px #232946cc;
      --text: #f7f7fa;
      --text-muted: #bfc6e0;
      --icon-bg: rgba(255,255,255,0.08);
      --icon-hover: #f6c177;
    }
    body {
      font-family: 'Poppins', 'Segoe UI' !important;
      margin: 0;
      padding: 0 0 0 0;
      background: var(--bg-gradient);
      min-height: 100vh;
      color: var(--text);
      letter-spacing: 0.01em;
    }
    @media (min-width: 700px) {
      body {
        padding: 0 32px 0 32px;
      }
    }
    @media (max-width: 700px) {
      body {
        padding: 0 4vw 0 4vw;
      }
    }
    .glass-card {
      background: var(--glass-bg);
      border-radius: 22px;
      box-shadow: 0 8px 32px #181c2a99;
      border: 1.5px solid var(--glass-border);
      backdrop-filter: blur(var(--glass-blur));
      -webkit-backdrop-filter: blur(var(--glass-blur));
    }
    header {
      text-align: center;
      margin-top: 40px;
      margin-bottom: 18px;
      padding: 0 0 0 0;
    }
    .app-title {
      display: inline-flex;
      align-items: center;
      gap: 14px;
      font-size: 2.3em;
      font-weight: 700;
      color: var(--primary);
      letter-spacing: 0.01em;
      margin-bottom: 2px;
    }
    .subtitle {
      font-size: 1.12em;
      color: var(--text-muted);
      margin-top: 6px;
      margin-bottom: 0;
    }
    .main-layout {
      display: flex;
      gap: 36px;
      max-width: 1100px;
      margin: 0 auto 32px auto;
      align-items: flex-start;
      justify-content: center;
      flex-wrap: wrap;
      padding: 0 0 0 0;
    }
    @media (min-width: 700px) {
      .main-layout {
        padding: 0 12px 0 12px;
      }
    }
    @media (max-width: 700px) {
      .main-layout {
        padding: 0 2vw 0 2vw;
      }
    }
    .map-area {
      flex: 2 1 420px;
      min-width: 320px;
      max-width: 700px;
      min-height: 420px;
      padding: 32px 28px 24px 28px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      position: relative;
      box-sizing: border-box;
    }
    .asset-panel {
      flex: 1 1 220px;
      min-width: 220px;
      max-width: 320px;
      padding: 28px 18px 22px 18px;
      display: flex;
      flex-direction: column;
      gap: 22px;
      align-items: stretch;
      box-sizing: border-box;
    }
    .toolbar {
      display: flex;
      gap: 16px;
      align-items: center;
      margin-bottom: 22px;
      flex-wrap: wrap;
      padding: 0 0 0 0;
    }
    .toolbar select, .toolbar button {
      font-size: 1em;
      border-radius: 8px;
      border: 1.5px solid var(--glass-border);
      padding: 7px 16px;
      background: var(--icon-bg);
      color: var(--text);
      box-shadow: 0 1px 4px #23294644;
      transition: border 0.2s, box-shadow 0.2s, background 0.2s, color 0.2s;
      outline: none;
      margin-right: 2px;
    }
    .toolbar select:focus, .toolbar button:focus {
      border: 1.5px solid var(--primary);
      box-shadow: 0 2px 8px var(--primary);
      background: var(--icon-bg);
      color: var(--primary);
    }
    .toolbar button {
      font-family: 'Poppins', 'Segoe UI' !important;
      cursor: pointer;
      font-weight: 500;
      background: var(--icon-bg);
      color: var(--primary);
      border: none;
      margin-left: 2px;
      margin-right: 2px;
    }
    .toolbar button:active {
      background: var(--accent);
      color: #fff;
    }
    .map-canvas-card {
      font-family: 'Poppins', 'Segoe UI' !important;
      width: 100%;
      min-height: 340px;
      background: #fff2;
      border-radius: 18px;
      box-shadow: 0 4px 24px #23294655;
      border: 1.5px solid var(--glass-border);
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 24px;
      position: relative;
      overflow: hidden;
    }
    #container {
      width: 100%;
      height: 420px;
      min-height: 320px;
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 2px 8px #23294633;
      border: none;
      margin: 0 auto;
      display: block;
      touch-action: none;
      position: relative;
      overflow: hidden;
      transition: box-shadow 0.3s;
      padding: 0;
    }
    .asset-title {
      font-size: 1.18em;
      font-weight: 600;
      color: var(--primary);
      margin-bottom: 14px;
      letter-spacing: 0.01em;
    }
    .asset-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 12px;
      max-height: 220px;
      overflow-y: auto;
      padding-right: 2px;
    }
    .asset-item {
      display: flex;
      align-items: center;
      gap: 12px;
      background: var(--icon-bg);
      border-radius: 10px;
      padding: 10px 16px;
      font-size: 1.08em;
      color: var(--text);
      cursor: grab;
      transition: background 0.15s, color 0.15s;
      border: 1.5px solid transparent;
    }
    .asset-item:active, .asset-item:focus {
      background: var(--icon-hover);
      color: #fff;
      border: 1.5px solid var(--accent);
    }
    .asset-icon {
      font-size: 1.4em;
      background: var(--icon-bg);
      border-radius: 8px;
      padding: 4px 8px;
      margin-right: 2px;
      color: var(--primary);
      transition: background 0.15s, color 0.15s;
    }
    .asset-item:active .asset-icon, .asset-item:focus .asset-icon {
      background: var(--accent);
      color: #fff;
    }
    .asset-upload {
      margin-top: 12px;
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: flex-start;
    }
    .asset-upload input[type="file"] {
      display: none;
    }
    .upload-btn {
      background: var(--icon-bg);
      color: var(--primary);
      border: 1.5px solid var(--glass-border);
      border-radius: 8px;
      padding: 9px 18px;
      font-size: 1em;
      cursor: pointer;
      transition: background 0.15s, color 0.15s;
    }
    .upload-btn:active {
      background: var(--accent);
      color: #fff;
    }
    @media (max-width: 1100px) {
      .main-layout {
        flex-direction: column;
        gap: 18px;
        align-items: stretch;
      }
      .map-area, .asset-panel {
        max-width: 98vw;
      }
    }
    @media (max-width: 700px) {
      .main-layout {
        flex-direction: column;
        gap: 10px;
      }
      .map-area, .asset-panel {
        max-width: 100vw;
        min-width: 0;
        padding: 10px 2vw 8px 2vw;
      }
      #container {
        min-height: 180px;
        height: 48vw;
      }
    }
    .gps-status {
      display: inline-flex;
      align-items: center;
      padding: 4px 12px;
      border-radius: 16px;
      font-size: 14px;
      font-family: inherit;
      background: rgba(220,220,220,0.7);
      color: #444;
      margin-left: 12px;
      transition: background 0.3s, color 0.3s;
    }
    .gps-status .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 8px;
      background: #aaa;
      display: inline-block;
      transition: background 0.3s;
    }
    .gps-status.on {
      background: rgba(60,200,120,0.15);
      color: #2a7a4f;
    }
    .gps-status.on .dot {
      background: #2ecc71;
      animation: pulse 1s infinite;
    }
    .gps-status.off {
      background: rgba(220,220,220,0.7);
      color: #888;
    }
    .gps-status.off .dot {
      background: #aaa;
    }
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 #2ecc7144; }
      70% { box-shadow: 0 0 0 8px #2ecc7100; }
      100% { box-shadow: 0 0 0 0 #2ecc7100; }
    }
    /* Landmark popup styling */
    .landmark-popup {
      position: fixed;
      background: var(--glass-bg);
      border: 1.5px solid var(--glass-border);
      border-radius: 16px;
      box-shadow: 0 8px 32px #181c2a99;
      backdrop-filter: blur(var(--glass-blur));
      -webkit-backdrop-filter: blur(var(--glass-blur));
      padding: 18px 20px 14px 20px;
      z-index: 9999;
      min-width: 220px;
      color: var(--text);
      font-family: inherit;
      transition: background 0.3s, color 0.3s;
    }
    .landmark-popup-title {
      font-weight: 600;
      margin-bottom: 10px;
      color: var(--accent);
      font-size: 1.08em;
    }
    .landmark-popup-input {
      width: 100%;
      font-size: 1em;
      padding: 7px 10px;
      border-radius: 8px;
      border: 1.5px solid var(--glass-border);
      margin-bottom: 12px;
      color: var(--text);
      background: var(--icon-bg);
      outline: none;
      transition: border 0.2s, background 0.2s, color 0.2s;
    }
    .landmark-popup-input:focus {
      border: 1.5px solid var(--primary);
      background: var(--glass-bg);
      color: var(--primary);
    }
    .landmark-popup-actions {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }
    .landmark-popup-btn {
      border: none;
      border-radius: 8px;
      padding: 7px 18px;
      font-size: 1em;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.15s, color 0.15s;
    }
    .landmark-popup-btn.save {
      background: var(--accent);
      color: #fff;
    }
    .landmark-popup-btn.cancel {
      background: var(--icon-bg);
      color: var(--text);
    }
    .landmark-popup-btn.delete {
      background: #c0392b;
      color: #fff;
      margin-left: 8px;
    }
  </style>
</head>
<body>
  <header>
    <div class="app-title">
      <span>🗺️</span>
      <span>Pathix</span>
    </div>
    <div class="subtitle">Design, annotate, and export property maps with ease</div>
  </header>
  <div class="main-layout">
    <div class="map-area glass-card">
      <div class="toolbar">
        <label for="theme-select">Theme:</label>
        <select id="theme-select">
          <option value="classic">Classic</option>
          <option value="night">Night</option>
        </select>
        <button id="start-gps">Start GPS Tracking</button>
        <button id="stop-gps" disabled>Stop GPS Tracking</button>
        <button id="export-map">Export Map</button>
      </div>
      <div class="map-canvas-card">
        <div id="container"></div>
      </div>
    </div>
    <aside class="asset-panel glass-card">
      <div class="asset-title">Assets</div>
      <div class="asset-list" id="landmark-palette"></div>
      <div class="asset-upload">
        <button class="upload-btn">Upload</button>
        <span style="color:var(--text-muted); font-size:0.98em;">(Coming soon)</span>
      </div>
      <div id="gps-status" class="gps-status off">
        <span class="dot"></span>
        GPS Tracking: OFF
      </div>
    </aside>
  </div>
  <footer style="text-align:center; color:var(--text-muted); font-size:0.98em; margin-bottom:18px; margin-top:10px;">
    &copy; 2024 Pathix &mdash; Crafted with <span style="color:var(--accent);">&#10084;&#65039;</span>
  </footer>



  <script>
    // Theme definitions
    const themes = {
      classic: {
        background: '#e0e7ff',
        roadColor: '#374151',
      },
      night: {
        background: '#232946',
        roadColor: '#eebbc3',
      },
    };

    // Landmark emoji mapping
    const landmarkEmojis = {
      house: '🏠',
      tree: '🌳',
      building: '🏢',
      hospital: '🏥',
      police: '🚓',
      cafe: '☕',
      pool: '🏊',
      school: '🏫',
      toilet: '🚻',
      villa: '🏡',
      apartment: '🏬',
      shop: '🏪',
      church: '⛪',
      mosque: '🕌',
      synagogue: '🕍',
      bank: '🏦',
      fire: '🚒',
      pharmacy: '💊',
      restaurant: '🍽️',
      parking: '🅿️',
    };

    // Konva setup
    const width = 800;
    const height = 500;
    const stage = new Konva.Stage({
      container: 'container',
      width,
      height,
    });
    const backgroundLayer = new Konva.Layer();
    const roadLayer = new Konva.Layer();
    const landmarkLayer = new Konva.Layer();
    stage.add(backgroundLayer);
    stage.add(roadLayer);
    stage.add(landmarkLayer);

    // Draw background rect
    let bgRect = new Konva.Rect({
      x: 0, y: 0, width, height, fill: '#fff'
    });
    backgroundLayer.add(bgRect);
    backgroundLayer.draw();

    // Handle theme change
    document.getElementById('theme-select').addEventListener('change', (e) => {
      // Only update road color, not background
      backgroundLayer.draw();
    });

    // Road drawing
    let isDrawing = false;
    let currentLine = null;
    let currentTheme = 'classic';

    stage.on('mousedown touchstart', (e) => {
      // Only draw on empty space
      if (e.target !== stage) return;
      isDrawing = true;
      const pos = stage.getPointerPosition();
      const theme = themes[document.getElementById('theme-select').value];
      currentLine = new Konva.Line({
        stroke: theme.roadColor,
        strokeWidth: 8,
        points: [pos.x, pos.y],
        lineCap: 'round',
        lineJoin: 'round',
      });
      roadLayer.add(currentLine);
    });

    stage.on('mousemove touchmove', (e) => {
      if (!isDrawing || !currentLine) return;
      const pos = stage.getPointerPosition();
      const newPoints = currentLine.points().concat([pos.x, pos.y]);
      currentLine.points(newPoints);
      roadLayer.batchDraw();
    });

    stage.on('mouseup touchend', (e) => {
      isDrawing = false;
      currentLine = null;
    });

    // Drag and drop landmarks
    const palette = document.getElementById('landmark-palette');
    let dragType = null;

    palette.addEventListener('dragstart', (e) => {
      dragType = e.target.getAttribute('data-type');
    });
    palette.addEventListener('dragend', (e) => {
      dragType = null;
    });

    // Allow dropping on canvas
    const container = stage.container();
    container.addEventListener('dragover', (e) => {
      e.preventDefault();
    });
    container.addEventListener('drop', (e) => {
      e.preventDefault();
      if (!dragType) return;
      // Get mouse position relative to canvas
      const rect = container.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      addLandmark(dragType, x, y);
      dragType = null;
    });

    // --- Touch support for mobile drag-and-drop ---
    let touchLandmark = null;
    let touchType = null;
    let touchMoveHandler = null;
    let touchEndHandler = null;

    palette.addEventListener('touchstart', function(e) {
      const target = e.target.closest('.landmark-icon');
      if (!target) return;
      e.preventDefault();
      touchType = target.getAttribute('data-type');
      // Create a floating emoji
      touchLandmark = document.createElement('div');
      touchLandmark.textContent = target.textContent;
      touchLandmark.style.position = 'fixed';
      touchLandmark.style.fontSize = '32px';
      touchLandmark.style.pointerEvents = 'none';
      touchLandmark.style.zIndex = 9999;
      document.body.appendChild(touchLandmark);

      function moveTouchLandmark(touch) {
        touchLandmark.style.left = (touch.clientX - 16) + 'px';
        touchLandmark.style.top = (touch.clientY - 16) + 'px';
      }

      touchMoveHandler = function(ev) {
        if (ev.touches.length > 0) {
          moveTouchLandmark(ev.touches[0]);
        }
      };
      touchEndHandler = function(ev) {
        if (touchLandmark) {
          document.body.removeChild(touchLandmark);
          touchLandmark = null;
        }
        if (touchType && ev.changedTouches && ev.changedTouches.length > 0) {
          // Drop on map if finger is over the canvas
          const touch = ev.changedTouches[0];
          const rect = container.getBoundingClientRect();
          const x = touch.clientX - rect.left;
          const y = touch.clientY - rect.top;
          if (
            touch.clientX >= rect.left && touch.clientX <= rect.right &&
            touch.clientY >= rect.top && touch.clientY <= rect.bottom
          ) {
            addLandmark(touchType, x, y);
          }
        }
        touchType = null;
        window.removeEventListener('touchmove', touchMoveHandler);
        window.removeEventListener('touchend', touchEndHandler);
      };
      window.addEventListener('touchmove', touchMoveHandler);
      window.addEventListener('touchend', touchEndHandler);
      // Place at initial touch
      if (e.touches.length > 0) moveTouchLandmark(e.touches[0]);
    }, { passive: false });

    // --- Landmark label popup ---
    let popupDiv = null;
    let currentLandmark = null;
    function showLandmarkPopup(lmNode) {
      // Remove any existing popup
      if (popupDiv) popupDiv.remove();
      currentLandmark = lmNode;
      // Get position on screen
      const stageBox = stage.container().getBoundingClientRect();
      const absPos = lmNode.getAbsolutePosition();
      const x = stageBox.left + absPos.x;
      const y = stageBox.top + absPos.y;
      // Create popup
      popupDiv = document.createElement('div');
      popupDiv.className = 'landmark-popup';
      popupDiv.style.left = (x + 30) + 'px';
      popupDiv.style.top = (y - 10) + 'px';
      popupDiv.innerHTML = `
        <div class="landmark-popup-title">Edit Place Label</div>
        <input id="lm-label-input" class="landmark-popup-input" type="text" value="${lmNode.getAttr('label') || ''}" placeholder="Enter name or description..." />
        <div class="landmark-popup-actions">
          <button id="lm-label-save" class="landmark-popup-btn save">Save</button>
          <button id="lm-label-cancel" class="landmark-popup-btn cancel">Cancel</button>
          <button id="lm-label-delete" class="landmark-popup-btn delete">Delete</button>
        </div>
      `;
      document.body.appendChild(popupDiv);
      document.getElementById('lm-label-input').focus();
      // Save handler
      document.getElementById('lm-label-save').onclick = function() {
        const val = document.getElementById('lm-label-input').value.trim();
        lmNode.setAttr('label', val);
        updateLandmarkLabels();
        closeLandmarkPopup();
      };
      document.getElementById('lm-label-cancel').onclick = closeLandmarkPopup;
      document.getElementById('lm-label-delete').onclick = function() {
        // Remove the landmark and its label
        lmNode.destroy();
        updateLandmarkLabels();
        closeLandmarkPopup();
        landmarkLayer.batchDraw();
      };
      // Close on outside click
      setTimeout(() => {
        window.addEventListener('mousedown', outsidePopupClick);
        window.addEventListener('touchstart', outsidePopupClick);
      }, 0);
    }
    function closeLandmarkPopup() {
      if (popupDiv) popupDiv.remove();
      popupDiv = null;
      currentLandmark = null;
      window.removeEventListener('mousedown', outsidePopupClick);
      window.removeEventListener('touchstart', outsidePopupClick);
    }
    function outsidePopupClick(e) {
      if (popupDiv && !popupDiv.contains(e.target)) closeLandmarkPopup();
    }
    // Add label text below each landmark
    function updateLandmarkLabels() {
      // Remove all label nodes
      landmarkLayer.getChildren().forEach(node => {
        if (node.getAttr('isLabel')) node.destroy();
      });
      // For each landmark, add label if present
      landmarkLayer.getChildren().forEach(lm => {
        if (lm.className === 'Text' && lm.getAttr('label')) {
          const label = new Konva.Text({
            x: lm.x(),
            y: lm.y() + 32,
            text: lm.getAttr('label'),
            fontSize: 15,
            fill: 'var(--text)',
            fontStyle: 'bold',
            align: 'center',
            width: 40,
            offsetX: 4,
            isLabel: true
          });
          label.x(lm.x() - (label.width() - 32) / 2);
          landmarkLayer.add(label);
        }
      });
      landmarkLayer.batchDraw();
    }
    // Listen for click/tap on landmarks
    stage.on('click tap', function(e) {
      if (e.target.getParent() === landmarkLayer && e.target.className === 'Text') {
        showLandmarkPopup(e.target);
      }
    });

    function addLandmark(type, x, y) {
      const emoji = landmarkEmojis[type] || '❓';
      const text = new Konva.Text({
        x: x - 16,
        y: y - 16,
        text: emoji,
        fontSize: 32,
        draggable: true,
        shadowColor: '#000',
        shadowBlur: 4,
        shadowOffset: { x: 2, y: 2 },
        shadowOpacity: 0.3,
      });
      landmarkLayer.add(text);
      landmarkLayer.draw();
      updateLandmarkLabels();
      console.log('Landmark added:', { type, x, y });
    }

    // GPS Road Drawing
    let gpsWatchId = null;
    let gpsLine = null;
    let gpsPath = [];
    let gpsOrigin = null; // {lat, lng}
    const gpsScale = 10000; // scale factor for lat/lng to px (adjust as needed)

    function latLngToCanvas(lat, lng) {
      if (!gpsOrigin) return {x: width/2, y: height/2};
      // Simple equirectangular projection, not for large distances
      const x = width/2 + (lng - gpsOrigin.lng) * gpsScale;
      const y = height/2 - (lat - gpsOrigin.lat) * gpsScale;
      return {x, y};
    }

    function setGpsStatus(isOn) {
      const status = document.getElementById('gps-status');
      if (isOn) {
        status.classList.add('on');
        status.classList.remove('off');
        status.textContent = '';
        status.innerHTML = '<span class="dot"></span>GPS Tracking: ON';
      } else {
        status.classList.add('off');
        status.classList.remove('on');
        status.textContent = '';
        status.innerHTML = '<span class="dot"></span>GPS Tracking: OFF';
      }
    }

    document.getElementById('start-gps').onclick = function() {
      if (!navigator.geolocation) {
        alert('Geolocation is not supported by your browser.');
        return;
      }
      this.disabled = true;
      document.getElementById('stop-gps').disabled = false;
      gpsPath = [];
      gpsOrigin = null;
      if (gpsLine) { gpsLine.destroy(); gpsLine = null; }
      const theme = themes[document.getElementById('theme-select').value];
      gpsLine = new Konva.Line({
        stroke: theme.roadColor,
        strokeWidth: 8,
        points: [],
        lineCap: 'round',
        lineJoin: 'round',
      });
      roadLayer.add(gpsLine);
      roadLayer.draw();
      gpsWatchId = navigator.geolocation.watchPosition(function(pos) {
        const { latitude: lat, longitude: lng } = pos.coords;
        if (!gpsOrigin) {
          gpsOrigin = { lat, lng };
        }
        gpsPath.push({ lat, lng });
        const pt = latLngToCanvas(lat, lng);
        const newPoints = gpsLine.points().concat([pt.x, pt.y]);
        gpsLine.points(newPoints);
        roadLayer.batchDraw();
      }, function(err) {
        alert('Error getting GPS position: ' + err.message);
        document.getElementById('start-gps').disabled = false;
        document.getElementById('stop-gps').disabled = true;
      }, {
        enableHighAccuracy: true,
        maximumAge: 0,
        timeout: 10000
      });
      setGpsStatus(true);
    };

    document.getElementById('stop-gps').onclick = function() {
      if (gpsWatchId !== null) {
        navigator.geolocation.clearWatch(gpsWatchId);
        gpsWatchId = null;
      }
      this.disabled = true;
      document.getElementById('start-gps').disabled = false;
      // gpsPath now contains the recorded GPS coordinates
      // You can use gpsPath for later tracking or export
      // Example: console.log('GPS Path:', gpsPath);
      setGpsStatus(false);
    };

    // Helper to convert an image to a data URL
    function imageToDataURL(img) {
      const canvas = document.createElement('canvas');
      canvas.width = img.width;
      canvas.height = img.height;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0);
      return canvas.toDataURL('image/png');
    }

    // Export Map Functionality
    document.getElementById('export-map').onclick = function() {
      // Collect roads
      const roads = [];
      roadLayer.getChildren().forEach(line => {
        if (line.className === 'Line') {
          // Convert canvas points to lat/lng if possible
          // We'll store as canvas points for now, but if GPS origin/scale is set, convert
          if (gpsOrigin) {
            const pts = line.points();
            const arr = [];
            for (let i = 0; i < pts.length; i += 2) {
              // Inverse of latLngToCanvas
              const x = pts[i];
              const y = pts[i+1];
              const lng = ((x - width/2) / gpsScale) + gpsOrigin.lng;
              const lat = gpsOrigin.lat - ((y - height/2) / gpsScale);
              arr.push({ lat, lng });
            }
            roads.push({ points: arr });
          } else {
            // fallback: just store canvas points
            roads.push({ points: line.points() });
          }
        }
      });
      // Collect landmarks
      const landmarks = [];
      landmarkLayer.getChildren().forEach(lm => {
        if (lm.className === 'Text') {
          // Convert canvas x/y to lat/lng if possible
          let type = null;
          for (const key in landmarkEmojis) {
            if (landmarkEmojis[key] === lm.text()) type = key;
          }
          let lat = null, lng = null;
          if (gpsOrigin) {
            const x = lm.x() + 16;
            const y = lm.y() + 16;
            lng = ((x - width/2) / gpsScale) + gpsOrigin.lng;
            lat = gpsOrigin.lat - ((y - height/2) / gpsScale);
          }
          landmarks.push({ type, lat, lng });
        }
      });
      // Collect all image-based icons and emoji landmarks as images
      const icons = [];
      landmarkLayer.getChildren().forEach(node => {
        if (node.className === 'Image' && node.image()) {
          icons.push({
            type: node.getAttr('type') || '',
            x: node.x(),
            y: node.y(),
            width: node.width(),
            height: node.height(),
            src: node.image().src // should be a data URL
          });
        } else if (node.className === 'Text') {
          // Render emoji to canvas and export as image
          const canvas = document.createElement('canvas');
          canvas.width = 40;
          canvas.height = 40;
          const ctx = canvas.getContext('2d');
          ctx.font = '32px Poppins, Segoe UI, Arial, sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(node.text(), 20, 20);
          const dataUrl = canvas.toDataURL('image/png');
          icons.push({
            type: (() => {
              for (const key in landmarkEmojis) {
                if (landmarkEmojis[key] === node.text()) return key;
              }
              return '';
            })(),
            x: node.x(),
            y: node.y(),
            width: 32,
            height: 32,
            src: dataUrl
          });
        }
      });
      // Convert background image to data URL
      let bgDataUrl = null;
      if (bgImg && bgImg.complete && bgImg.naturalWidth > 0) {
        bgDataUrl = imageToDataURL(bgImg);
      }
      // Convert custom icon to data URL
      let iconDataUrl = null;
      if (iconImg && iconImg.complete && iconImg.naturalWidth > 0) {
        iconDataUrl = imageToDataURL(iconImg);
      }
      // Compose map data
      const mapData = {
        gpsOrigin: gpsOrigin || { lat: 28.6139, lng: 77.2090 },
        gpsScale,
        roads,
        landmarks,
        icons,
        assets: {
          background: bgDataUrl,
          landmarkHotel: iconDataUrl
        }
      };
      // Download as JSON
      const blob = new Blob([JSON.stringify(mapData, null, 2)], {type: 'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'property-map.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    };

    // --- Add after Konva stage setup ---

    // Initial scale and position
    let scaleBy = 1.1;
    let minScale = 0.5;
    let maxScale = 4;

    // Zoom with mouse wheel
    stage.container().addEventListener('wheel', (e) => {
      e.preventDefault();
      const oldScale = stage.scaleX();
      const pointer = stage.getPointerPosition();

      let direction = e.deltaY > 0 ? -1 : 1;
      let newScale = direction > 0 ? oldScale * scaleBy : oldScale / scaleBy;
      newScale = Math.max(minScale, Math.min(maxScale, newScale));

      // Calculate new position to keep pointer under mouse
      const mousePointTo = {
        x: (pointer.x - stage.x()) / oldScale,
        y: (pointer.y - stage.y()) / oldScale,
      };

      stage.scale({ x: newScale, y: newScale });

      const newPos = {
        x: pointer.x - mousePointTo.x * newScale,
        y: pointer.y - mousePointTo.y * newScale,
      };
      stage.position(newPos);
      stage.batchDraw();
    });

    // Pan with drag
    let lastDist = null;
    let lastCenter = null;

    stage.on('mousedown touchstart', (e) => {
      if (e.evt.touches && e.evt.touches.length === 2) {
        // Pinch start
        const [touch1, touch2] = e.evt.touches;
        lastDist = Math.hypot(
          touch1.clientX - touch2.clientX,
          touch1.clientY - touch2.clientY
        );
        lastCenter = {
          x: (touch1.clientX + touch2.clientX) / 2,
          y: (touch1.clientY + touch2.clientY) / 2,
        };
      } else {
        stage.draggable(true);
      }
    });

    stage.on('mouseup touchend', (e) => {
      stage.draggable(false);
      lastDist = null;
      lastCenter = null;
    });

    stage.on('touchmove', (e) => {
      if (e.evt.touches && e.evt.touches.length === 2) {
        // Pinch zoom
        const [touch1, touch2] = e.evt.touches;
        const dist = Math.hypot(
          touch1.clientX - touch2.clientX,
          touch1.clientY - touch2.clientY
        );
        const center = {
          x: (touch1.clientX + touch2.clientX) / 2,
          y: (touch1.clientY + touch2.clientY) / 2,
        };
        if (lastDist && lastCenter) {
          let scale = stage.scaleX() * (dist / lastDist);
          scale = Math.max(minScale, Math.min(maxScale, scale));
          stage.scale({ x: scale, y: scale });

          // Adjust position to keep center under fingers
          const dx = center.x - lastCenter.x;
          const dy = center.y - lastCenter.y;
          stage.position({
            x: stage.x() + dx,
            y: stage.y() + dy,
          });
          stage.batchDraw();
        }
        lastDist = dist;
        lastCenter = center;
      }
    });

    // Dynamically render the landmark palette for better separation and maintainability
    const landmarkPalette = document.getElementById('landmark-palette');
    const landmarkIcons = [
      { type: 'house', icon: '🏠', label: 'Home' },
      { type: 'tree', icon: '🌳', label: 'Landmark' },
      { type: 'building', icon: '🏢', label: 'Building' },
      { type: 'hospital', icon: '🏥', label: 'Hospital' },
      { type: 'police', icon: '🚓', label: 'Police' },
      { type: 'cafe', icon: '☕', label: 'Cafe' },
      { type: 'pool', icon: '🏊', label: 'Pool' },
      { type: 'school', icon: '🏫', label: 'School' },
      { type: 'toilet', icon: '🚻', label: 'Toilet' },
      { type: 'villa', icon: '🏡', label: 'Villa' },
      { type: 'apartment', icon: '🏬', label: 'Apartment' },
      { type: 'shop', icon: '🏪', label: 'Shop' },
      { type: 'church', icon: '⛪', label: 'Church' },
      { type: 'mosque', icon: '🕌', label: 'Mosque' },
      { type: 'synagogue', icon: '🕍', label: 'Synagogue' },
      { type: 'bank', icon: '🏦', label: 'Bank' },
      { type: 'fire', icon: '🚒', label: 'Fire' },
      { type: 'pharmacy', icon: '💊', label: 'Pharmacy' },
      { type: 'restaurant', icon: '🍽️', label: 'Restaurant' },
      { type: 'parking', icon: '🅿️', label: 'Parking' },
    ];
    landmarkPalette.innerHTML = landmarkIcons.map(lm =>
      `<div class="asset-item" tabindex="0" draggable="true" data-type="${lm.type}">
        <span class="asset-icon">${lm.icon}</span>
        <span>${lm.label}</span>
      </div>`
    ).join('');

    // Update labels on dragmove
    landmarkLayer.on('dragmove', updateLandmarkLabels);
    // Initial call in case of reload
    updateLandmarkLabels();

    // Theme color palettes
    const uiThemes = {
      classic: {
        '--bg-gradient': 'linear-gradient(135deg, #fefae0 0%, #faedcd 100%)',
        '--glass-bg': 'rgba(255,255,255,0.75)',
        '--glass-border': 'rgba(212,163,115,0.18)',
        '--glass-blur': '12px',
        '--primary': '#d4a373',
        '--accent': '#b08968',
        '--button-glow': '0 0 16px #d4a37388, 0 2px 8px #b08968cc',
        '--text': '#3c2f2f',
        '--text-muted': '#b08968',
        '--icon-bg': 'rgba(212,163,115,0.08)',
        '--icon-hover': '#b08968',
      },
      night: {
        '--bg-gradient': 'linear-gradient(135deg, #232946 0%, #181c2a 100%)',
        '--glass-bg': 'rgba(36, 41, 61, 0.65)',
        '--glass-border': 'rgba(255,255,255,0.12)',
        '--glass-blur': '18px',
        '--primary': '#a3bffa',
        '--accent': '#f6c177',
        '--button-glow': '0 0 16px #f6c17788, 0 2px 8px #232946cc',
        '--text': '#f7f7fa',
        '--text-muted': '#bfc6e0',
        '--icon-bg': 'rgba(255,255,255,0.08)',
        '--icon-hover': '#f6c177',
      }
    };
    function setUITheme(theme) {
      const vars = uiThemes[theme] || uiThemes.night;
      for (const key in vars) {
        document.documentElement.style.setProperty(key, vars[key]);
      }
    }
    // Set default theme
    setUITheme('night');
    // Listen for theme change
    document.addEventListener('DOMContentLoaded', function() {
      const themeSelect = document.getElementById('theme-select');
      if (themeSelect) {
        themeSelect.addEventListener('change', function(e) {
          setUITheme(e.target.value);
        });
      }
    });

    // Load background
    const bgImg = new window.Image();
    bgImg.src = 'Assets/bg1.png';
    bgImg.onload = () => {
      const bg = new Konva.Image({ image: bgImg, width: stage.width(), height: stage.height() });
      backgroundLayer.add(bg);
      backgroundLayer.moveToBottom(bg);
      stage.add(backgroundLayer);
    };

    // Add a custom landmark icon
    const iconImg = new window.Image();
    iconImg.src = 'assets/landmark-hotel.png';
    iconImg.onload = () => {
      const icon = new Konva.Image({
        image: iconImg,
        x: 200,
        y: 300,
        width: 80,
        height: 80,
        draggable: true
      });
      landmarkLayer.add(icon);
      stage.add(landmarkLayer);
    };
  </script>
</body>
</html> 