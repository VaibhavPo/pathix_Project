<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pathix</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/konva@9.2.0/konva.min.js"></script>
  <link rel="stylesheet" href="style_index.css">
</head>
<body>
  <header>
    <div class="app-title">
      <span>üó∫Ô∏è</span>
      <span>Pathix</span>
    </div>
    <div class="subtitle">Design, annotate, and export property maps with ease</div>
  </header>
  <div class="main-layout">
    <div class="map-area glass-card">
      <div class="toolbar">
        <label for="theme-select">Theme:</label>
        <select id="theme-select">
          <option value="classic">Classic</option>
          <option value="night">Night</option>
        </select>
        <button id="start-gps">Start GPS Tracking</button>
        <button id="stop-gps" disabled>Stop GPS Tracking</button>
        <button id="export-map">Export Map</button>
        <button id="simulate-route">Simulate Route</button>
      </div>
      <div class="map-canvas-card">
        <div id="container"></div>
      </div>
    </div>
    <aside class="asset-panel glass-card">
      <div class="asset-title">Assets</div>
      <div class="asset-list" id="landmark-palette"></div>
      <div class="asset-upload">
        <button class="upload-btn">Upload</button>
        <span style="color:var(--text-muted); font-size:0.98em;">(Coming soon)</span>
      </div>
      <div id="gps-status" class="gps-status off">
        <span class="dot"></span>
        GPS Tracking: OFF
      </div>
    </aside>
  </div>
  <footer style="text-align:center; color:var(--text-muted); font-size:0.98em; margin-bottom:18px; margin-top:10px;">
    &copy; 2024 Pathix &mdash; Crafted with <span style="color:var(--accent);">&#10084;&#65039;</span>
  </footer>



  <script>
    // Theme definitions
    const themes = {
      classic: {
        background: '#e0e7ff',
        roadColor: '#374151',
      },
      night: {
        background: '#232946',
        roadColor: '#eebbc3',
      },
    };

    // Landmark emoji mapping
    const landmarkEmojis = {
      house: 'üè†',
      tree: 'üå≥',
      building: 'üè¢',
      hospital: 'üè•',
      police: 'üöì',
      cafe: '‚òï',
      pool: 'üèä',
      school: 'üè´',
      toilet: 'üöª',
      villa: 'üè°',
      apartment: 'üè¨',
      shop: 'üè™',
      church: '‚õ™',
      mosque: 'üïå',
      synagogue: 'üïç',
      bank: 'üè¶',
      fire: 'üöí',
      pharmacy: 'üíä',
      restaurant: 'üçΩÔ∏è',
      parking: 'üÖøÔ∏è',
    };

    // Konva setup
    const width = 800;
    const height = 500;
    const stage = new Konva.Stage({
      container: 'container',
      width,
      height,
    });
    const backgroundLayer = new Konva.Layer();
    const roadLayer = new Konva.Layer();
    const landmarkLayer = new Konva.Layer();
    stage.add(backgroundLayer);
    stage.add(roadLayer);
    stage.add(landmarkLayer);

    // Draw background rect
    let bgRect = new Konva.Rect({
      x: 0, y: 0, width, height, fill: '#fff'
    });
    backgroundLayer.add(bgRect);
    backgroundLayer.draw();

    document.getElementById('theme-select').addEventListener('change', (e) => {
  currentTheme = e.target.value;
  const theme = themes[currentTheme];

  // Update background color if no image is loaded
  if (!bgImg.complete || bgImg.naturalWidth === 0) {
    bgRect.fill(theme.background);
  }

  // Update GPS and drawn road colors
  roadLayer.getChildren().forEach((line) => {
    if (line.className === 'Line') {
      line.stroke(theme.roadColor);
    }
  });
  roadLayer.batchDraw();
});


    // Road drawing
    let isDrawing = false;
    let currentLine = null;
    let currentTheme = 'classic';

    stage.on('mousedown touchstart', (e) => {
      // Only draw on empty space
      if (e.target !== stage) return;
      isDrawing = true;
      const pos = stage.getPointerPosition();
      const theme = themes[document.getElementById('theme-select').value];
      currentLine = new Konva.Line({
        stroke: theme.roadColor,
        strokeWidth: 8,
        points: [pos.x, pos.y],
        lineCap: 'round',
        lineJoin: 'round',
      });
      roadLayer.add(currentLine);
    });

    stage.on('mousemove touchmove', (e) => {
      if (!isDrawing || !currentLine) return;
      const pos = stage.getPointerPosition();
      const newPoints = currentLine.points().concat([pos.x, pos.y]);
      currentLine.points(newPoints);
      roadLayer.batchDraw();
    });

    stage.on('mouseup touchend', (e) => {
      isDrawing = false;
      currentLine = null;
    });

    // Drag and drop landmarks
    const palette = document.getElementById('landmark-palette');
    let dragType = null;

    palette.addEventListener('dragstart', (e) => {
      dragType = e.target.getAttribute('data-type');
    });
    palette.addEventListener('dragend', (e) => {
      dragType = null;
    });

    // Allow dropping on canvas
    const container = stage.container();
    container.addEventListener('dragover', (e) => {
      e.preventDefault();
    });
    container.addEventListener('drop', (e) => {
      e.preventDefault();
      if (!dragType) return;
      // Get mouse position relative to canvas
      const rect = container.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      addLandmark(dragType, x, y);
      dragType = null;
    });

    // --- Touch support for mobile drag-and-drop ---
    let touchLandmark = null;
    let touchType = null;
    let touchMoveHandler = null;
    let touchEndHandler = null;

    palette.addEventListener('touchstart', function(e) {
      const target = e.target.closest('.landmark-icon');
      if (!target) return;
      e.preventDefault();
      touchType = target.getAttribute('data-type');
      // Create a floating emoji
      touchLandmark = document.createElement('div');
      touchLandmark.textContent = target.textContent;
      touchLandmark.style.position = 'fixed';
      touchLandmark.style.fontSize = '32px';
      touchLandmark.style.pointerEvents = 'none';
      touchLandmark.style.zIndex = 9999;
      document.body.appendChild(touchLandmark);

      function moveTouchLandmark(touch) {
        touchLandmark.style.left = (touch.clientX - 16) + 'px';
        touchLandmark.style.top = (touch.clientY - 16) + 'px';
      }

      touchMoveHandler = function(ev) {
        if (ev.touches.length > 0) {
          moveTouchLandmark(ev.touches[0]);
        }
      };
      touchEndHandler = function(ev) {
        if (touchLandmark) {
          document.body.removeChild(touchLandmark);
          touchLandmark = null;
        }
        if (touchType && ev.changedTouches && ev.changedTouches.length > 0) {
          // Drop on map if finger is over the canvas
          const touch = ev.changedTouches[0];
          const rect = container.getBoundingClientRect();
          const x = touch.clientX - rect.left;
          const y = touch.clientY - rect.top;
          if (
            touch.clientX >= rect.left && touch.clientX <= rect.right &&
            touch.clientY >= rect.top && touch.clientY <= rect.bottom
          ) {
            addLandmark(touchType, x, y);
          }
        }
        touchType = null;
        window.removeEventListener('touchmove', touchMoveHandler);
        window.removeEventListener('touchend', touchEndHandler);
      };
      window.addEventListener('touchmove', touchMoveHandler);
      window.addEventListener('touchend', touchEndHandler);
      // Place at initial touch
      if (e.touches.length > 0) moveTouchLandmark(e.touches[0]);
    }, { passive: false });

    // --- Landmark label popup ---
    let popupDiv = null;
    let currentLandmark = null;
    function showLandmarkPopup(lmNode) {
      // Remove any existing popup
      if (popupDiv) popupDiv.remove();
      currentLandmark = lmNode;
      // Get position on screen
      const stageBox = stage.container().getBoundingClientRect();
      const absPos = lmNode.getAbsolutePosition();
      const x = stageBox.left + absPos.x;
      const y = stageBox.top + absPos.y;
      // Create popup
      popupDiv = document.createElement('div');
      popupDiv.className = 'landmark-popup';
      popupDiv.style.left = (x + 30) + 'px';
      popupDiv.style.top = (y - 10) + 'px';
      popupDiv.innerHTML = `
        <div class="landmark-popup-title">Edit Place Label</div>
        <input id="lm-label-input" class="landmark-popup-input" type="text" value="${lmNode.getAttr('label') || ''}" placeholder="Enter name or description..." />
        <div class="landmark-popup-actions">
          <button id="lm-label-save" class="landmark-popup-btn save">Save</button>
          <button id="lm-label-cancel" class="landmark-popup-btn cancel">Cancel</button>
          <button id="lm-label-delete" class="landmark-popup-btn delete">Delete</button>
        </div>
      `;
      document.body.appendChild(popupDiv);
      document.getElementById('lm-label-input').focus();
      // Save handler
      document.getElementById('lm-label-save').onclick = function() {
        const val = document.getElementById('lm-label-input').value.trim();
        lmNode.setAttr('label', val);
        updateLandmarkLabels();
        closeLandmarkPopup();
      };
      document.getElementById('lm-label-cancel').onclick = closeLandmarkPopup;
      document.getElementById('lm-label-delete').onclick = function() {
        // Remove the landmark and its label
        lmNode.destroy();
        updateLandmarkLabels();
        closeLandmarkPopup();
        landmarkLayer.batchDraw();
      };
      // Close on outside click
      setTimeout(() => {
        window.addEventListener('mousedown', outsidePopupClick);
        window.addEventListener('touchstart', outsidePopupClick);
      }, 0);
    }
    function closeLandmarkPopup() {
      if (popupDiv) popupDiv.remove();
      popupDiv = null;
      currentLandmark = null;
      window.removeEventListener('mousedown', outsidePopupClick);
      window.removeEventListener('touchstart', outsidePopupClick);
    }
    function outsidePopupClick(e) {
      if (popupDiv && !popupDiv.contains(e.target)) closeLandmarkPopup();
    }
    // Add label text below each landmark
    function updateLandmarkLabels() {
      // Remove all label nodes
      landmarkLayer.getChildren().forEach(node => {
        if (node.getAttr('isLabel')) node.destroy();
      });
      // For each landmark, add label if present
      landmarkLayer.getChildren().forEach(lm => {
        if (lm.className === 'Text' && lm.getAttr('label')) {
          const label = new Konva.Text({
            x: lm.x(),
            y: lm.y() + 32,
            text: lm.getAttr('label'),
            fontSize: 15,
            fill: 'var(--text)',
            fontStyle: 'bold',
            align: 'center',
            width: 40,
            offsetX: 4,
            isLabel: true
          });
          label.x(lm.x() - (label.width() - 32) / 2);
          landmarkLayer.add(label);
        }
      });
      landmarkLayer.batchDraw();
    }
    // Listen for click/tap on landmarks
    stage.on('click tap', function(e) {
      if (e.target.getParent() === landmarkLayer && e.target.className === 'Text') {
        showLandmarkPopup(e.target);
      }
    });

    function addLandmark(type, x, y) {
      const emoji = landmarkEmojis[type] || '‚ùì';
      const text = new Konva.Text({
        x: x - 16,
        y: y - 16,
        text: emoji,
        fontSize: 32,
        draggable: true,
        shadowColor: '#000',
        shadowBlur: 4,
        shadowOffset: { x: 2, y: 2 },
        shadowOpacity: 0.3,
      });
      landmarkLayer.add(text);
      landmarkLayer.draw();
      updateLandmarkLabels();
      console.log('Landmark added:', { type, x, y });
    }

    // GPS Road Drawing
    let gpsWatchId = null;
    let gpsLine = null;
    let gpsPath = [];
    let gpsOrigin = { lat: 28.6139, lng: 77.2090 };
    const gpsScale = 10000;

    function latLngToCanvas(lat, lng) {
      if (!gpsOrigin) return {x: width/2, y: height/2};
      // Simple equirectangular projection, not for large distances
      const x = width/2 + (lng - gpsOrigin.lng) * gpsScale;
      const y = height/2 - (lat - gpsOrigin.lat) * gpsScale;
      return {x, y};
    }

    function setGpsStatus(isOn) {
      const status = document.getElementById('gps-status');
      if (isOn) {
        status.classList.add('on');
        status.classList.remove('off');
        status.textContent = '';
        status.innerHTML = '<span class="dot"></span>GPS Tracking: ON';
      } else {
        status.classList.add('off');
        status.classList.remove('on');
        status.textContent = '';
        status.innerHTML = '<span class="dot"></span>GPS Tracking: OFF';
      }
    }

    document.getElementById('start-gps').onclick = function() {
      if (!navigator.geolocation) {
        alert('Geolocation is not supported by your browser.');
        return;
      }
      this.disabled = true;
      document.getElementById('stop-gps').disabled = false;
      gpsPath = [];
      gpsOrigin = null;
      if (gpsLine) { gpsLine.destroy(); gpsLine = null; }
      const theme = themes[document.getElementById('theme-select').value];
      gpsLine = new Konva.Line({
        stroke: theme.roadColor,
        strokeWidth: 8,
        points: [],
        lineCap: 'round',
        lineJoin: 'round',
      });
      roadLayer.add(gpsLine);
      roadLayer.draw();
      gpsWatchId = navigator.geolocation.watchPosition(function(pos) {
        const { latitude: lat, longitude: lng } = pos.coords;
        if (!gpsOrigin) {
          gpsOrigin = { lat, lng };
        }
        gpsPath.push({ lat, lng });
        const pt = latLngToCanvas(lat, lng);
        const newPoints = gpsLine.points().concat([pt.x, pt.y]);
        gpsLine.points(newPoints);
        roadLayer.batchDraw();
      }, function(err) {
        alert('Error getting GPS position: ' + err.message);
        document.getElementById('start-gps').disabled = false;
        document.getElementById('stop-gps').disabled = true;
      }, {
        enableHighAccuracy: true,
        maximumAge: 0,
        timeout: 10000
      });
      setGpsStatus(true);
    };

    document.getElementById('stop-gps').onclick = function() {
      if (gpsWatchId !== null) {
        navigator.geolocation.clearWatch(gpsWatchId);
        gpsWatchId = null;
      }
      this.disabled = true;
      document.getElementById('start-gps').disabled = false;
      // gpsPath now contains the recorded GPS coordinates
      // You can use gpsPath for later tracking or export
      // Example: console.log('GPS Path:', gpsPath);
      setGpsStatus(false);
    };

    // Helper to convert an image to a data URL
    function imageToDataURL(img) {
      const canvas = document.createElement('canvas');
      canvas.width = img.width;
      canvas.height = img.height;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0);
      return canvas.toDataURL('image/png');
    }

    // Export Map Functionality
    document.getElementById('export-map').onclick = function() {
      // Collect roads
      const roads = [];
      roadLayer.getChildren().forEach(line => {
        if (line.className === 'Line') {
          // Convert canvas points to lat/lng if possible
          // We'll store as canvas points for now, but if GPS origin/scale is set, convert
          if (gpsOrigin) {
            const pts = line.points();
            const arr = [];
            for (let i = 0; i < pts.length; i += 2) {
              // Inverse of latLngToCanvas
              const x = pts[i];
              const y = pts[i+1];
              const lng = ((x - width/2) / gpsScale) + gpsOrigin.lng;
              const lat = gpsOrigin.lat - ((y - height/2) / gpsScale);
              arr.push({ lat, lng });
            }
            roads.push({ points: arr });
          } else {
            // fallback: just store canvas points
            roads.push({ points: line.points() });
          }
        }
      });
      // Collect landmarks
      const landmarks = [];
      landmarkLayer.getChildren().forEach(lm => {
        if (lm.className === 'Text') {
          // Convert canvas x/y to lat/lng if possible
          let type = null;
          for (const key in landmarkEmojis) {
            if (landmarkEmojis[key] === lm.text()) type = key;
          }
          let lat = null, lng = null;
          if (gpsOrigin) {
            const x = lm.x() + 16;
            const y = lm.y() + 16;
            lng = ((x - width/2) / gpsScale) + gpsOrigin.lng;
            lat = gpsOrigin.lat - ((y - height/2) / gpsScale);
          }
          landmarks.push({ type, lat, lng });
        }
      });
      // Collect all image-based icons and emoji landmarks as images
      const icons = [];
      landmarkLayer.getChildren().forEach(node => {
        if (node.className === 'Image' && node.image()) {
          icons.push({
            type: node.getAttr('type') || '',
            x: node.x(),
            y: node.y(),
            width: node.width(),
            height: node.height(),
            src: node.image().src // should be a data URL
          });
        } else if (node.className === 'Text') {
          // Render emoji to canvas and export as image
          const canvas = document.createElement('canvas');
          canvas.width = 40;
          canvas.height = 40;
          const ctx = canvas.getContext('2d');
          ctx.font = '32px Poppins, Segoe UI, Arial, sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(node.text(), 20, 20);
          const dataUrl = canvas.toDataURL('image/png');
          icons.push({
            type: (() => {
              for (const key in landmarkEmojis) {
                if (landmarkEmojis[key] === node.text()) return key;
              }
              return '';
            })(),
            x: node.x(),
            y: node.y(),
            width: 32,
            height: 32,
            src: dataUrl
          });
        }
      });
      // Convert background image to data URL
      let bgDataUrl = null;
      if (bgImg && bgImg.complete && bgImg.naturalWidth > 0) {
        bgDataUrl = imageToDataURL(bgImg);
      }
      // Convert custom icon to data URL
      let iconDataUrl = null;
      if (iconImg && iconImg.complete && iconImg.naturalWidth > 0) {
        iconDataUrl = imageToDataURL(iconImg);
      }
      // Compose map data
      const mapData = {
        gpsOrigin: gpsOrigin || { lat: 28.6139, lng: 77.2090 },
        gpsScale,
        roads,
        landmarks,
        icons,
        assets: {
          background: bgDataUrl,
          landmarkHotel: iconDataUrl
        }
      };
      // Download as JSON
      const blob = new Blob([JSON.stringify(mapData, null, 2)], {type: 'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'property-map.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    };

    // --- Add after Konva stage setup ---

    // Initial scale and position
    let scaleBy = 1.1;
    let minScale = 0.5;
    let maxScale = 4;

    // Zoom with mouse wheel
    stage.container().addEventListener('wheel', (e) => {
      e.preventDefault();
      const oldScale = stage.scaleX();
      const pointer = stage.getPointerPosition();

      let direction = e.deltaY > 0 ? -1 : 1;
      let newScale = direction > 0 ? oldScale * scaleBy : oldScale / scaleBy;
      newScale = Math.max(minScale, Math.min(maxScale, newScale));

      // Calculate new position to keep pointer under mouse
      const mousePointTo = {
        x: (pointer.x - stage.x()) / oldScale,
        y: (pointer.y - stage.y()) / oldScale,
      };

      stage.scale({ x: newScale, y: newScale });

      const newPos = {
        x: pointer.x - mousePointTo.x * newScale,
        y: pointer.y - mousePointTo.y * newScale,
      };
      stage.position(newPos);
      stage.batchDraw();
    });

    // Pan with drag
    let lastDist = null;
    let lastCenter = null;

    stage.on('mousedown touchstart', (e) => {
      if (e.evt.touches && e.evt.touches.length === 2) {
        // Pinch start
        const [touch1, touch2] = e.evt.touches;
        lastDist = Math.hypot(
          touch1.clientX - touch2.clientX,
          touch1.clientY - touch2.clientY
        );
        lastCenter = {
          x: (touch1.clientX + touch2.clientX) / 2,
          y: (touch1.clientY + touch2.clientY) / 2,
        };
      } else {
        stage.draggable(true);
      }
    });

    stage.on('mouseup touchend', (e) => {
      stage.draggable(false);
      lastDist = null;
      lastCenter = null;
    });

    stage.on('touchmove', (e) => {
      if (e.evt.touches && e.evt.touches.length === 2) {
        // Pinch zoom
        const [touch1, touch2] = e.evt.touches;
        const dist = Math.hypot(
          touch1.clientX - touch2.clientX,
          touch1.clientY - touch2.clientY
        );
        const center = {
          x: (touch1.clientX + touch2.clientX) / 2,
          y: (touch1.clientY + touch2.clientY) / 2,
        };
        if (lastDist && lastCenter) {
          let scale = stage.scaleX() * (dist / lastDist);
          scale = Math.max(minScale, Math.min(maxScale, scale));
          stage.scale({ x: scale, y: scale });

          // Adjust position to keep center under fingers
          const dx = center.x - lastCenter.x;
          const dy = center.y - lastCenter.y;
          stage.position({
            x: stage.x() + dx,
            y: stage.y() + dy,
          });
          stage.batchDraw();
        }
        lastDist = dist;
        lastCenter = center;
      }
    });

    // Dynamically render the landmark palette for better separation and maintainability
    const landmarkPalette = document.getElementById('landmark-palette');
    const landmarkIcons = [
      { type: 'house', icon: 'üè†', label: 'Home' },
      { type: 'tree', icon: 'üå≥', label: 'Landmark' },
      { type: 'building', icon: 'üè¢', label: 'Building' },
      { type: 'hospital', icon: 'üè•', label: 'Hospital' },
      { type: 'police', icon: 'üöì', label: 'Police' },
      { type: 'cafe', icon: '‚òï', label: 'Cafe' },
      { type: 'pool', icon: 'üèä', label: 'Pool' },
      { type: 'school', icon: 'üè´', label: 'School' },
      { type: 'toilet', icon: 'üöª', label: 'Toilet' },
      { type: 'villa', icon: 'üè°', label: 'Villa' },
      { type: 'apartment', icon: 'üè¨', label: 'Apartment' },
      { type: 'shop', icon: 'üè™', label: 'Shop' },
      { type: 'church', icon: '‚õ™', label: 'Church' },
      { type: 'mosque', icon: 'üïå', label: 'Mosque' },
      { type: 'synagogue', icon: 'üïç', label: 'Synagogue' },
      { type: 'bank', icon: 'üè¶', label: 'Bank' },
      { type: 'fire', icon: 'üöí', label: 'Fire' },
      { type: 'pharmacy', icon: 'üíä', label: 'Pharmacy' },
      { type: 'restaurant', icon: 'üçΩÔ∏è', label: 'Restaurant' },
      { type: 'parking', icon: 'üÖøÔ∏è', label: 'Parking' },
    ];
    landmarkPalette.innerHTML = landmarkIcons.map(lm =>
      `<div class="asset-item" tabindex="0" draggable="true" data-type="${lm.type}">
        <span class="asset-icon">${lm.icon}</span>
        <span>${lm.label}</span>
      </div>`
    ).join('');

    // Update labels on dragmove
    landmarkLayer.on('dragmove', updateLandmarkLabels);
    // Initial call in case of reload
    updateLandmarkLabels();

    // Theme color palettes
    const uiThemes = {
      classic: {
        '--bg-gradient': 'linear-gradient(135deg, #fefae0 0%, #faedcd 100%)',
        '--glass-bg': 'rgba(255,255,255,0.75)',
        '--glass-border': 'rgba(212,163,115,0.18)',
        '--glass-blur': '12px',
        '--primary': '#d4a373',
        '--accent': '#b08968',
        '--button-glow': '0 0 16px #d4a37388, 0 2px 8px #b08968cc',
        '--text': '#3c2f2f',
        '--text-muted': '#b08968',
        '--icon-bg': 'rgba(212,163,115,0.08)',
        '--icon-hover': '#b08968',
      },
      night: {
        '--bg-gradient': 'linear-gradient(135deg, #232946 0%, #181c2a 100%)',
        '--glass-bg': 'rgba(36, 41, 61, 0.65)',
        '--glass-border': 'rgba(255,255,255,0.12)',
        '--glass-blur': '18px',
        '--primary': '#a3bffa',
        '--accent': '#f6c177',
        '--button-glow': '0 0 16px #f6c17788, 0 2px 8px #232946cc',
        '--text': '#f7f7fa',
        '--text-muted': '#bfc6e0',
        '--icon-bg': 'rgba(255,255,255,0.08)',
        '--icon-hover': '#f6c177',
      }
    };
    function setUITheme(theme) {
      const vars = uiThemes[theme] || uiThemes.night;
      for (const key in vars) {
        document.documentElement.style.setProperty(key, vars[key]);
      }
    }
    // Set default theme
    setUITheme('night');
    // Listen for theme change
    document.addEventListener('DOMContentLoaded', function() {
      const themeSelect = document.getElementById('theme-select');
      if (themeSelect) {
        themeSelect.addEventListener('change', function(e) {
          setUITheme(e.target.value);
        });
      }
    });

    const bgImg = new window.Image();
bgImg.src = 'Assets/bg1.png';
bgImg.onload = () => {
  const bg = new Konva.Image({
    image: bgImg,
    width: stage.width(),
    height: stage.height(),
  });

  // Add the image below everything else
  backgroundLayer.add(bg);
  bg.moveToBottom();

  // Optional: hide the background rect if image is present
  bgRect.visible(false);

  backgroundLayer.draw();
};

    // Add a custom landmark icon
    const iconImg = new window.Image();
    iconImg.src = 'assets/landmark-hotel.png';
    iconImg.onload = () => {
      const icon = new Konva.Image({
        image: iconImg,
        x: 200,
        y: 300,
        width: 80,
        height: 80,
        draggable: true
      });
      landmarkLayer.add(icon);
      stage.add(landmarkLayer);
    };

    document.getElementById('simulate-route').onclick = function() {
      // Remove previous simulated route if any
      if (window.simLine) {
        window.simLine.destroy();
        window.simLine = null;
      }

      // Set a simulated GPS origin
      gpsOrigin = { lat: 28.6139, lng: 77.2090 }; // Example: New Delhi
      // Define a simulated route (array of lat/lng)
      const simRoute = [
        { lat: 28.6139, lng: 77.2090 },
        { lat: 28.6145, lng: 77.2100 },
        { lat: 28.6150, lng: 77.2110 },
        { lat: 28.6155, lng: 77.2120 },
        { lat: 28.6160, lng: 77.2130 }
      ];

      // Convert lat/lng to canvas points
      const simPoints = [];
      simRoute.forEach(pt => {
        const canvasPt = latLngToCanvas(pt.lat, pt.lng);
        console.log('Simulated point:', canvasPt); // Debug: log the points
        simPoints.push(canvasPt.x, canvasPt.y);
      });

      // Draw the simulated route
      window.simLine = new Konva.Line({
        stroke: '#ff0000', // bright red for visibility
        strokeWidth: 8,
        points: simPoints,
        lineCap: 'round',
        lineJoin: 'round',
        dash: [16, 8] // Dashed line for simulation
      });
      roadLayer.add(window.simLine);
      roadLayer.draw();
    };
  </script>
</body>
</html> 