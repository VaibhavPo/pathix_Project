<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Property Map Tracker</title>
  <script src="https://cdn.jsdelivr.net/npm/konva@9.2.0/konva.min.js"></script>
  <style>
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      margin: 0;
      padding: 0;
      background: linear-gradient(135deg, #e0e7ff 0%, #f0f0f0 100%);
      min-height: 100vh;
    }
    #info {
      margin: 24px auto 0 auto;
      max-width: 95vw;
      width: 420px;
      background: #fff;
      border-radius: 16px;
      box-shadow: 0 4px 24px rgba(60,60,120,0.10);
      color: #222;
      padding: 20px 18px 10px 18px;
      text-align: center;
    }
    #container {
      margin: 18px auto 24px auto;
      display: block;
      background: #fff;
      border-radius: 16px;
      border: 1px solid #d1d5db;
      box-shadow: 0 2px 12px rgba(60,60,120,0.07);
      max-width: 500px;
      width: 100%;
      aspect-ratio: 4/3;
      min-width: 220px;
      min-height: 180px;
      touch-action: none;
      position: relative;
      overflow: hidden;
    }
    #nav-instruction {
      font-size: 1.1em;
      font-weight: bold;
      color: #1d4ed8;
      margin: 10px 0 8px 0;
      letter-spacing: 0.01em;
    }
    #marker-size-slider {
      width: 120px;
      accent-color: #1d4ed8;
      margin: 0 8px;
      vertical-align: middle;
    }
    #status {
      font-size: 0.98em;
      color: #666;
      margin-top: 10px;
    }
    input[type="file"] {
      margin: 8px 0 10px 0;
      font-size: 1em;
      border-radius: 6px;
      border: 1px solid #d1d5db;
      padding: 4px 8px;
      background: #f9fafb;
      color: #222;
    }
    @media (max-width: 600px) {
      #info, #container {
        width: 98vw;
        min-width: 0;
        max-width: 100vw;
        border-radius: 10px;
        padding: 10px 2vw 8px 2vw;
      }
      #container {
        height: 60vw;
        max-height: 70vw;
        min-height: 180px;
      }
      #nav-instruction {
        font-size: 1em;
      }
      #marker-size-slider {
        width: 80px;
      }
    }
  </style>
</head>
<body>
  <div id="info">
    <h2>Property Map Tracker</h2>
    <p>This map shows the property and your current location (if you allow GPS access).</p>
    <input type="file" id="map-upload" accept="application/json" />
    <div id="nav-instruction" style="font-size:1.2em; font-weight:bold; color:#1d4ed8; margin:10px 0;"></div>
    <label for="marker-size-slider" style="font-size:1em;">Marker Size:</label>
    <input type="range" id="marker-size-slider" min="6" max="40" value="12" style="vertical-align:middle;">
    <span id="marker-size-value">12</span> px
    <p id="status">Waiting for GPS...</p>
  </div>
  <div id="container"></div>
  <script>
    // --- Paste your exported map data here ---
    // Example structure:
    const mapData = {
      gpsOrigin: { lat: 28.6139, lng: 77.2090 }, // Set this to your map's origin
      gpsScale: 10000, // Set this to your map's scale
      roads: [
        // Each road: { points: [ {lat, lng}, ... ] }
        // Example: { points: [ {lat: 28.6139, lng: 77.2090}, {lat: 28.6140, lng: 77.2091} ] }
      ],
      landmarks: [
        // Each landmark: { type: 'house', lat, lng }
      ],
      route: [
        // Example: { lat: 28.6139, lng: 77.2090 }, { lat: 28.6141, lng: 77.2092 }, ...
      ]
    };
    // --- End map data ---

    // Emoji for landmarks
    const landmarkEmojis = {
      house: '🏠',
      tree: '🌳',
    };

    // Konva setup
    function getContainerSize() {
      const container = document.getElementById('container');
      return {
        width: container.clientWidth,
        height: container.clientHeight
      };
    }

    let { width, height } = getContainerSize();
    const stage = new Konva.Stage({
      container: 'container',
      width,
      height,
    });
    const backgroundLayer = new Konva.Layer();
    const roadLayer = new Konva.Layer();
    const landmarkLayer = new Konva.Layer();
    const userLayer = new Konva.Layer();
    const routeLayer = new Konva.Layer();
    stage.add(backgroundLayer);
    stage.add(roadLayer);
    stage.add(landmarkLayer);
    stage.add(userLayer);
    stage.add(routeLayer);

    // Draw background
    let bgRect = new Konva.Rect({
      x: 0, y: 0, width, height, fill: '#e0e7ff'
    });
    backgroundLayer.add(bgRect);
    backgroundLayer.draw();

    // Helper: lat/lng to canvas
    function latLngToCanvas(lat, lng) {
      const { gpsOrigin, gpsScale } = mapData;
      if (!gpsOrigin) return {x: width/2, y: height/2};
      const x = width/2 + (lng - gpsOrigin.lng) * gpsScale;
      const y = height/2 - (lat - gpsOrigin.lat) * gpsScale;
      return {x, y};
    }

    // Draw roads
    const baseRoadWidth = 8;
    function drawRoads() {
      roadLayer.destroyChildren();
      mapData.roads.forEach(road => {
        if (road.points.length < 2) return;
        const points = road.points.map(pt => {
          const c = latLngToCanvas(pt.lat, pt.lng);
          return [c.x, c.y];
        }).flat();
        const line = new Konva.Line({
          points,
          stroke: '#374151',
          strokeWidth: baseRoadWidth / stage.scaleX(),
          lineCap: 'round',
          lineJoin: 'round',
        });
        roadLayer.add(line);
      });
      roadLayer.draw();
    }
    drawRoads();

    // Draw landmarks
    mapData.landmarks.forEach(lm => {
      const c = latLngToCanvas(lm.lat, lm.lng);
      const text = new Konva.Text({
        x: c.x - 16,
        y: c.y - 16,
        text: landmarkEmojis[lm.type] || '❓',
        fontSize: 32,
        shadowColor: '#000',
        shadowBlur: 4,
        shadowOffset: { x: 2, y: 2 },
        shadowOpacity: 0.3,
      });
      landmarkLayer.add(text);
    });
    landmarkLayer.draw();

    // User marker
    let baseMarkerRadius = 12;
    const userMarker = new Konva.Circle({
      x: width/2, y: height/2, radius: baseMarkerRadius, fill: '#1d4ed8', stroke: '#fff', strokeWidth: 3, visible: false
    });
    userLayer.add(userMarker);
    userLayer.draw();

    // Draw route if present
    const baseRouteWidth = 5;
    function drawRoute() {
      routeLayer.destroyChildren();
      if (Array.isArray(mapData.route) && mapData.route.length > 1) {
        const points = mapData.route.map(pt => {
          const c = latLngToCanvas(pt.lat, pt.lng);
          return [c.x, c.y];
        }).flat();
        const line = new Konva.Line({
          points,
          stroke: '#f59e42',
          strokeWidth: baseRouteWidth / stage.scaleX(),
          lineCap: 'round',
          lineJoin: 'round',
          dash: [10, 8],
        });
        routeLayer.add(line);
        routeLayer.draw();
      }
    }
    drawRoute();

    // Track user position
    function updateUserMarker(lat, lng) {
      const c = latLngToCanvas(lat, lng);
      userMarker.x(c.x);
      userMarker.y(c.y);
      userMarker.visible(true);
      userLayer.batchDraw();
      updateNavigation(lat, lng);
    }

    if (navigator.geolocation) {
      navigator.geolocation.watchPosition(function(pos) {
        const { latitude: lat, longitude: lng } = pos.coords;
        updateUserMarker(lat, lng);
        document.getElementById('status').textContent = `Your position: ${lat.toFixed(5)}, ${lng.toFixed(5)}`;
      }, function(err) {
        document.getElementById('status').textContent = 'Unable to get your position: ' + err.message;
      }, {
        enableHighAccuracy: true,
        maximumAge: 0,
        timeout: 10000
      });
    } else {
      document.getElementById('status').textContent = 'Geolocation is not supported by your browser.';
    }

    // --- Map Upload Functionality ---
    document.getElementById('map-upload').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(evt) {
        try {
          const data = JSON.parse(evt.target.result);
          if (!data.gpsOrigin || !data.gpsScale || !Array.isArray(data.roads) || !Array.isArray(data.landmarks)) {
            throw new Error('Invalid map data format.');
          }
          // Remove old map
          roadLayer.destroyChildren();
          landmarkLayer.destroyChildren();
          routeLayer.destroyChildren();
          // Update mapData
          mapData.gpsOrigin = data.gpsOrigin;
          mapData.gpsScale = data.gpsScale;
          mapData.roads = data.roads;
          mapData.landmarks = data.landmarks;
          mapData.route = data.route || [];
          // Redraw roads
          drawRoads();
          // Redraw landmarks
          mapData.landmarks.forEach(lm => {
            const c = latLngToCanvas(lm.lat, lm.lng);
            const text = new Konva.Text({
              x: c.x - 16,
              y: c.y - 16,
              text: landmarkEmojis[lm.type] || '❓',
              fontSize: 32,
              shadowColor: '#000',
              shadowBlur: 4,
              shadowOffset: { x: 2, y: 2 },
              shadowOpacity: 0.3,
            });
            landmarkLayer.add(text);
          });
          landmarkLayer.draw();
          // Redraw route
          drawRoute();
        } catch (err) {
          alert('Failed to load map: ' + err.message);
        }
      };
      reader.readAsText(file);
    });

    // --- Enable Zoom and Pan ---
    let scaleBy = 1.1;
    let minScale = 0.5;
    let maxScale = 4;

    // Zoom with mouse wheel
    stage.container().addEventListener('wheel', (e) => {
      e.preventDefault();
      const oldScale = stage.scaleX();
      const pointer = stage.getPointerPosition();

      let direction = e.deltaY > 0 ? -1 : 1;
      let newScale = direction > 0 ? oldScale * scaleBy : oldScale / scaleBy;
      newScale = Math.max(minScale, Math.min(maxScale, newScale));

      // Calculate new position to keep pointer under mouse
      const mousePointTo = {
        x: (pointer.x - stage.x()) / oldScale,
        y: (pointer.y - stage.y()) / oldScale,
      };

      stage.scale({ x: newScale, y: newScale });

      const newPos = {
        x: pointer.x - mousePointTo.x * newScale,
        y: pointer.y - mousePointTo.y * newScale,
      };
      stage.position(newPos);
      stage.batchDraw();
      updateScales();
    });

    // Pan with drag
    let lastDist = null;
    let lastCenter = null;

    stage.on('mousedown touchstart', (e) => {
      if (e.evt.touches && e.evt.touches.length === 2) {
        // Pinch start
        const [touch1, touch2] = e.evt.touches;
        lastDist = Math.hypot(
          touch1.clientX - touch2.clientX,
          touch1.clientY - touch2.clientY
        );
        lastCenter = {
          x: (touch1.clientX + touch2.clientX) / 2,
          y: (touch1.clientY + touch2.clientY) / 2,
        };
      } else {
        stage.draggable(true);
      }
    });

    stage.on('mouseup touchend', (e) => {
      stage.draggable(false);
      lastDist = null;
      lastCenter = null;
    });

    stage.on('touchmove', (e) => {
      if (e.evt.touches && e.evt.touches.length === 2) {
        // Pinch zoom
        const [touch1, touch2] = e.evt.touches;
        const dist = Math.hypot(
          touch1.clientX - touch2.clientX,
          touch1.clientY - touch2.clientY
        );
        const center = {
          x: (touch1.clientX + touch2.clientX) / 2,
          y: (touch1.clientY + touch2.clientY) / 2,
        };
        if (lastDist && lastCenter) {
          let scale = stage.scaleX() * (dist / lastDist);
          scale = Math.max(minScale, Math.min(maxScale, scale));
          stage.scale({ x: scale, y: scale });

          // Adjust position to keep center under fingers
          const dx = center.x - lastCenter.x;
          const dy = center.y - lastCenter.y;
          stage.position({
            x: stage.x() + dx,
            y: stage.y() + dy,
          });
          stage.batchDraw();
          updateScales();
        }
        lastDist = dist;
        lastCenter = center;
      }
    });

    // --- Navigation Suggestion Logic ---
    function getDistance(a, b) {
      // Approximate, for small distances
      const dx = (a.lat - b.lat) * 111320;
      const dy = (a.lng - b.lng) * 40075000 * Math.cos((a.lat + b.lat) * Math.PI / 360) / 360;
      return Math.sqrt(dx*dx + dy*dy);
    }
    function getHeading(a, b) {
      // Returns angle in degrees from north
      const dLon = (b.lng - a.lng) * Math.PI / 180;
      const y = Math.sin(dLon) * Math.cos(b.lat * Math.PI / 180);
      const x = Math.cos(a.lat * Math.PI / 180) * Math.sin(b.lat * Math.PI / 180) -
                Math.sin(a.lat * Math.PI / 180) * Math.cos(b.lat * Math.PI / 180) * Math.cos(dLon);
      let brng = Math.atan2(y, x) * 180 / Math.PI;
      return (brng + 360) % 360;
    }
    function getTurnInstruction(userPos, prevPos, route) {
      if (!route || route.length < 2) return '';
      // Find closest segment
      let minDist = Infinity, segIdx = 0;
      for (let i = 0; i < route.length - 1; i++) {
        const dist = getDistance(userPos, route[i]);
        if (dist < minDist) {
          minDist = dist;
          segIdx = i;
        }
      }
      // Heading of route segment
      const segA = route[segIdx];
      const segB = route[segIdx + 1] || segA;
      const routeHeading = getHeading(segA, segB);
      // User movement heading
      let userHeading = null;
      if (prevPos) userHeading = getHeading(prevPos, userPos);
      // Compare headings
      if (userHeading !== null) {
        let diff = (routeHeading - userHeading + 540) % 360 - 180;
        if (Math.abs(diff) < 25) return 'Go straight';
        if (diff > 25) return 'Turn right';
        if (diff < -25) return 'Turn left';
      }
      return 'Follow the route';
    }
    let prevUserPos = null;
    function updateNavigation(userLat, userLng) {
      const route = mapData.route;
      if (!route || route.length < 2) {
        document.getElementById('nav-instruction').textContent = '';
        return;
      }
      const userPos = { lat: userLat, lng: userLng };
      const instruction = getTurnInstruction(userPos, prevUserPos, route);
      document.getElementById('nav-instruction').textContent = instruction;
      prevUserPos = userPos;
    }

    // Update marker and road/route widths on zoom/pan
    function updateScales() {
      const scale = stage.scaleX();
      userMarker.radius(baseMarkerRadius / scale);
      // Update all road lines
      roadLayer.getChildren().forEach(line => {
        if (line.className === 'Line') line.strokeWidth(baseRoadWidth / scale);
      });
      // Update all route lines
      routeLayer.getChildren().forEach(line => {
        if (line.className === 'Line') line.strokeWidth(baseRouteWidth / scale);
      });
      roadLayer.batchDraw();
      routeLayer.batchDraw();
      userLayer.batchDraw();
    }

    // Marker size slider logic
    const markerSizeSlider = document.getElementById('marker-size-slider');
    const markerSizeValue = document.getElementById('marker-size-value');
    markerSizeSlider.addEventListener('input', function() {
      baseMarkerRadius = parseInt(this.value, 10);
      markerSizeValue.textContent = baseMarkerRadius;
      updateScales();
    });

    // Responsive resize logic
    function resizeStage() {
      const size = getContainerSize();
      width = size.width;
      height = size.height;
      stage.width(width);
      stage.height(height);
      bgRect.width(width);
      bgRect.height(height);
      backgroundLayer.batchDraw();
      drawRoads();
      drawRoute();
      // Redraw landmarks
      landmarkLayer.destroyChildren();
      mapData.landmarks.forEach(lm => {
        const c = latLngToCanvas(lm.lat, lm.lng);
        const text = new Konva.Text({
          x: c.x - 16,
          y: c.y - 16,
          text: landmarkEmojis[lm.type] || '❓',
          fontSize: 32,
          shadowColor: '#000',
          shadowBlur: 4,
          shadowOffset: { x: 2, y: 2 },
          shadowOpacity: 0.3,
        });
        landmarkLayer.add(text);
      });
      landmarkLayer.batchDraw();
      updateScales();
    }

    window.addEventListener('resize', resizeStage);
    // Initial resize to fit container
    setTimeout(resizeStage, 0);
  </script>
</body>
</html> 