<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Property Map Tracker</title>
  <script src="https://cdn.jsdelivr.net/npm/konva@9.2.0/konva.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 0; padding: 0; background: #f0f0f0; }
    #container { margin: 30px auto; display: block; background: #fff; border: 1px solid #ccc; }
    #info { margin: 20px auto; width: 800px; color: #444; }
  </style>
</head>
<body>
  <div id="info">
    <h2>Property Map Tracker</h2>
    <p>This map shows the property and your current location (if you allow GPS access).</p>
    <input type="file" id="map-upload" accept="application/json" />
    <div id="nav-instruction" style="font-size:1.2em; font-weight:bold; color:#1d4ed8; margin:10px 0;"></div>
    <p id="status">Waiting for GPS...</p>
  </div>
  <div id="container"></div>
  <script>
    // --- Paste your exported map data here ---
    // Example structure:
    const mapData = {
      gpsOrigin: { lat: 28.6139, lng: 77.2090 }, // Set this to your map's origin
      gpsScale: 10000, // Set this to your map's scale
      roads: [
        // Each road: { points: [ {lat, lng}, ... ] }
        // Example: { points: [ {lat: 28.6139, lng: 77.2090}, {lat: 28.6140, lng: 77.2091} ] }
      ],
      landmarks: [
        // Each landmark: { type: 'house', lat, lng }
      ],
      route: [
        // Example: { lat: 28.6139, lng: 77.2090 }, { lat: 28.6141, lng: 77.2092 }, ...
      ]
    };
    // --- End map data ---

    // Emoji for landmarks
    const landmarkEmojis = {
      house: '🏠',
      tree: '🌳',
    };

    // Konva setup
    const width = 800;
    const height = 500;
    const stage = new Konva.Stage({
      container: 'container',
      width,
      height,
    });
    const backgroundLayer = new Konva.Layer();
    const roadLayer = new Konva.Layer();
    const landmarkLayer = new Konva.Layer();
    const userLayer = new Konva.Layer();
    const routeLayer = new Konva.Layer();
    stage.add(backgroundLayer);
    stage.add(roadLayer);
    stage.add(landmarkLayer);
    stage.add(userLayer);
    stage.add(routeLayer);

    // Draw background
    const bgRect = new Konva.Rect({
      x: 0, y: 0, width, height, fill: '#e0e7ff'
    });
    backgroundLayer.add(bgRect);
    backgroundLayer.draw();

    // Helper: lat/lng to canvas
    function latLngToCanvas(lat, lng) {
      const { gpsOrigin, gpsScale } = mapData;
      if (!gpsOrigin) return {x: width/2, y: height/2};
      const x = width/2 + (lng - gpsOrigin.lng) * gpsScale;
      const y = height/2 - (lat - gpsOrigin.lat) * gpsScale;
      return {x, y};
    }

    // Draw roads
    const baseRoadWidth = 8;
    function drawRoads() {
      roadLayer.destroyChildren();
      mapData.roads.forEach(road => {
        if (road.points.length < 2) return;
        const points = road.points.map(pt => {
          const c = latLngToCanvas(pt.lat, pt.lng);
          return [c.x, c.y];
        }).flat();
        const line = new Konva.Line({
          points,
          stroke: '#374151',
          strokeWidth: baseRoadWidth / stage.scaleX(),
          lineCap: 'round',
          lineJoin: 'round',
        });
        roadLayer.add(line);
      });
      roadLayer.draw();
    }
    drawRoads();

    // Draw landmarks
    mapData.landmarks.forEach(lm => {
      const c = latLngToCanvas(lm.lat, lm.lng);
      const text = new Konva.Text({
        x: c.x - 16,
        y: c.y - 16,
        text: landmarkEmojis[lm.type] || '❓',
        fontSize: 32,
        shadowColor: '#000',
        shadowBlur: 4,
        shadowOffset: { x: 2, y: 2 },
        shadowOpacity: 0.3,
      });
      landmarkLayer.add(text);
    });
    landmarkLayer.draw();

    // User marker
    const baseMarkerRadius = 12;
    const userMarker = new Konva.Circle({
      x: width/2, y: height/2, radius: baseMarkerRadius, fill: '#1d4ed8', stroke: '#fff', strokeWidth: 3, visible: false
    });
    userLayer.add(userMarker);
    userLayer.draw();

    // Draw route if present
    const baseRouteWidth = 5;
    function drawRoute() {
      routeLayer.destroyChildren();
      if (Array.isArray(mapData.route) && mapData.route.length > 1) {
        const points = mapData.route.map(pt => {
          const c = latLngToCanvas(pt.lat, pt.lng);
          return [c.x, c.y];
        }).flat();
        const line = new Konva.Line({
          points,
          stroke: '#f59e42',
          strokeWidth: baseRouteWidth / stage.scaleX(),
          lineCap: 'round',
          lineJoin: 'round',
          dash: [10, 8],
        });
        routeLayer.add(line);
        routeLayer.draw();
      }
    }
    drawRoute();

    // Track user position
    function updateUserMarker(lat, lng) {
      const c = latLngToCanvas(lat, lng);
      userMarker.x(c.x);
      userMarker.y(c.y);
      userMarker.visible(true);
      userLayer.batchDraw();
      updateNavigation(lat, lng);
    }

    if (navigator.geolocation) {
      navigator.geolocation.watchPosition(function(pos) {
        const { latitude: lat, longitude: lng } = pos.coords;
        updateUserMarker(lat, lng);
        document.getElementById('status').textContent = `Your position: ${lat.toFixed(5)}, ${lng.toFixed(5)}`;
      }, function(err) {
        document.getElementById('status').textContent = 'Unable to get your position: ' + err.message;
      }, {
        enableHighAccuracy: true,
        maximumAge: 0,
        timeout: 10000
      });
    } else {
      document.getElementById('status').textContent = 'Geolocation is not supported by your browser.';
    }

    // --- Map Upload Functionality ---
    document.getElementById('map-upload').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(evt) {
        try {
          const data = JSON.parse(evt.target.result);
          if (!data.gpsOrigin || !data.gpsScale || !Array.isArray(data.roads) || !Array.isArray(data.landmarks)) {
            throw new Error('Invalid map data format.');
          }
          // Remove old map
          roadLayer.destroyChildren();
          landmarkLayer.destroyChildren();
          routeLayer.destroyChildren();
          // Update mapData
          mapData.gpsOrigin = data.gpsOrigin;
          mapData.gpsScale = data.gpsScale;
          mapData.roads = data.roads;
          mapData.landmarks = data.landmarks;
          mapData.route = data.route || [];
          // Redraw roads
          drawRoads();
          // Redraw landmarks
          mapData.landmarks.forEach(lm => {
            const c = latLngToCanvas(lm.lat, lm.lng);
            const text = new Konva.Text({
              x: c.x - 16,
              y: c.y - 16,
              text: landmarkEmojis[lm.type] || '❓',
              fontSize: 32,
              shadowColor: '#000',
              shadowBlur: 4,
              shadowOffset: { x: 2, y: 2 },
              shadowOpacity: 0.3,
            });
            landmarkLayer.add(text);
          });
          landmarkLayer.draw();
          // Redraw route
          drawRoute();
        } catch (err) {
          alert('Failed to load map: ' + err.message);
        }
      };
      reader.readAsText(file);
    });

    // --- Enable Zoom and Pan ---
    let scaleBy = 1.1;
    let minScale = 0.5;
    let maxScale = 4;

    // Zoom with mouse wheel
    stage.container().addEventListener('wheel', (e) => {
      e.preventDefault();
      const oldScale = stage.scaleX();
      const pointer = stage.getPointerPosition();

      let direction = e.deltaY > 0 ? -1 : 1;
      let newScale = direction > 0 ? oldScale * scaleBy : oldScale / scaleBy;
      newScale = Math.max(minScale, Math.min(maxScale, newScale));

      // Calculate new position to keep pointer under mouse
      const mousePointTo = {
        x: (pointer.x - stage.x()) / oldScale,
        y: (pointer.y - stage.y()) / oldScale,
      };

      stage.scale({ x: newScale, y: newScale });

      const newPos = {
        x: pointer.x - mousePointTo.x * newScale,
        y: pointer.y - mousePointTo.y * newScale,
      };
      stage.position(newPos);
      stage.batchDraw();
      updateScales();
    });

    // Pan with drag
    let lastDist = null;
    let lastCenter = null;

    stage.on('mousedown touchstart', (e) => {
      if (e.evt.touches && e.evt.touches.length === 2) {
        // Pinch start
        const [touch1, touch2] = e.evt.touches;
        lastDist = Math.hypot(
          touch1.clientX - touch2.clientX,
          touch1.clientY - touch2.clientY
        );
        lastCenter = {
          x: (touch1.clientX + touch2.clientX) / 2,
          y: (touch1.clientY + touch2.clientY) / 2,
        };
      } else {
        stage.draggable(true);
      }
    });

    stage.on('mouseup touchend', (e) => {
      stage.draggable(false);
      lastDist = null;
      lastCenter = null;
    });

    stage.on('touchmove', (e) => {
      if (e.evt.touches && e.evt.touches.length === 2) {
        // Pinch zoom
        const [touch1, touch2] = e.evt.touches;
        const dist = Math.hypot(
          touch1.clientX - touch2.clientX,
          touch1.clientY - touch2.clientY
        );
        const center = {
          x: (touch1.clientX + touch2.clientX) / 2,
          y: (touch1.clientY + touch2.clientY) / 2,
        };
        if (lastDist && lastCenter) {
          let scale = stage.scaleX() * (dist / lastDist);
          scale = Math.max(minScale, Math.min(maxScale, scale));
          stage.scale({ x: scale, y: scale });

          // Adjust position to keep center under fingers
          const dx = center.x - lastCenter.x;
          const dy = center.y - lastCenter.y;
          stage.position({
            x: stage.x() + dx,
            y: stage.y() + dy,
          });
          stage.batchDraw();
          updateScales();
        }
        lastDist = dist;
        lastCenter = center;
      }
    });

    // --- Navigation Suggestion Logic ---
    function getDistance(a, b) {
      // Approximate, for small distances
      const dx = (a.lat - b.lat) * 111320;
      const dy = (a.lng - b.lng) * 40075000 * Math.cos((a.lat + b.lat) * Math.PI / 360) / 360;
      return Math.sqrt(dx*dx + dy*dy);
    }
    function getHeading(a, b) {
      // Returns angle in degrees from north
      const dLon = (b.lng - a.lng) * Math.PI / 180;
      const y = Math.sin(dLon) * Math.cos(b.lat * Math.PI / 180);
      const x = Math.cos(a.lat * Math.PI / 180) * Math.sin(b.lat * Math.PI / 180) -
                Math.sin(a.lat * Math.PI / 180) * Math.cos(b.lat * Math.PI / 180) * Math.cos(dLon);
      let brng = Math.atan2(y, x) * 180 / Math.PI;
      return (brng + 360) % 360;
    }
    function getTurnInstruction(userPos, prevPos, route) {
      if (!route || route.length < 2) return '';
      // Find closest segment
      let minDist = Infinity, segIdx = 0;
      for (let i = 0; i < route.length - 1; i++) {
        const dist = getDistance(userPos, route[i]);
        if (dist < minDist) {
          minDist = dist;
          segIdx = i;
        }
      }
      // Heading of route segment
      const segA = route[segIdx];
      const segB = route[segIdx + 1] || segA;
      const routeHeading = getHeading(segA, segB);
      // User movement heading
      let userHeading = null;
      if (prevPos) userHeading = getHeading(prevPos, userPos);
      // Compare headings
      if (userHeading !== null) {
        let diff = (routeHeading - userHeading + 540) % 360 - 180;
        if (Math.abs(diff) < 25) return 'Go straight';
        if (diff > 25) return 'Turn right';
        if (diff < -25) return 'Turn left';
      }
      return 'Follow the route';
    }
    let prevUserPos = null;
    function updateNavigation(userLat, userLng) {
      const route = mapData.route;
      if (!route || route.length < 2) {
        document.getElementById('nav-instruction').textContent = '';
        return;
      }
      const userPos = { lat: userLat, lng: userLng };
      const instruction = getTurnInstruction(userPos, prevUserPos, route);
      document.getElementById('nav-instruction').textContent = instruction;
      prevUserPos = userPos;
    }

    // Update marker and road/route widths on zoom/pan
    function updateScales() {
      const scale = stage.scaleX();
      userMarker.radius(baseMarkerRadius / scale);
      // Update all road lines
      roadLayer.getChildren().forEach(line => {
        if (line.className === 'Line') line.strokeWidth(baseRoadWidth / scale);
      });
      // Update all route lines
      routeLayer.getChildren().forEach(line => {
        if (line.className === 'Line') line.strokeWidth(baseRouteWidth / scale);
      });
      roadLayer.batchDraw();
      routeLayer.batchDraw();
      userLayer.batchDraw();
    }
  </script>
</body>
</html> 