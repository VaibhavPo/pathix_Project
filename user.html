<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Property Map Tracker</title>
  <script src="https://cdn.jsdelivr.net/npm/konva@9.2.0/konva.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-gradient: linear-gradient(135deg, #232946 0%, #181c2a 100%);
      --glass-bg: rgba(36, 41, 61, 0.65);
      --glass-border: rgba(255,255,255,0.12);
      --glass-blur: 18px;
      --primary: #a3bffa;
      --accent: #f6c177;
      --button-glow: 0 0 16px #f6c17788, 0 2px 8px #232946cc;
      --text: #f7f7fa;
      --text-muted: #bfc6e0;
      --icon-bg: rgba(255,255,255,0.08);
      --icon-hover: #f6c177;
    }
    body {
      font-family: 'Poppins', 'Segoe UI', Arial, sans-serif;
      margin: 0;
      padding: 0 0 0 0;
      background: var(--bg-gradient);
      min-height: 100vh;
      color: var(--text);
      letter-spacing: 0.01em;
    }
    @media (min-width: 700px) {
      body {
        padding: 0 32px 0 32px;
      }
    }
    @media (max-width: 700px) {
      body {
        padding: 0 4vw 0 4vw;
      }
    }
    .glass-card {
      background: var(--glass-bg);
      border-radius: 22px;
      box-shadow: 0 8px 32px #181c2a99;
      border: 1.5px solid var(--glass-border);
      backdrop-filter: blur(var(--glass-blur));
      -webkit-backdrop-filter: blur(var(--glass-blur));
    }
    header {
      text-align: center;
      margin-top: 40px;
      margin-bottom: 18px;
      padding: 0 0 0 0;
    }
    .app-title {
      display: inline-flex;
      align-items: center;
      gap: 14px;
      font-size: 2.3em;
      font-weight: 700;
      color: var(--primary);
      letter-spacing: 0.01em;
      text-shadow: 0 2px 8px #232946cc;
      margin-bottom: 2px;
    }
    .subtitle {
      font-size: 1.12em;
      color: var(--text-muted);
      margin-top: 6px;
      margin-bottom: 0;
    }
    .main-layout {
      display: flex;
      gap: 36px;
      max-width: 1100px;
      margin: 0 auto 32px auto;
      align-items: flex-start;
      justify-content: center;
      flex-wrap: wrap;
      padding: 0 0 0 0;
    }
    @media (min-width: 700px) {
      .main-layout {
        padding: 0 12px 0 12px;
      }
    }
    @media (max-width: 700px) {
      .main-layout {
        padding: 0 2vw 0 2vw;
      }
    }
    .map-area {
      flex: 2 1 420px;
      min-width: 320px;
      max-width: 700px;
      min-height: 420px;
      padding: 32px 28px 24px 28px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      position: relative;
      box-sizing: border-box;
    }
    .map-canvas-card {
      width: 100%;
      min-height: 340px;
      background: #fff2;
      border-radius: 18px;
      box-shadow: 0 4px 24px #23294655;
      border: 1.5px solid var(--glass-border);
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 24px;
      position: relative;
      overflow: hidden;
    }
    #container {
      width: 100%;
      height: 420px;
      min-height: 320px;
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 2px 8px #23294633;
      border: none;
      margin: 0 auto;
      display: block;
      touch-action: none;
      position: relative;
      overflow: hidden;
      transition: box-shadow 0.3s;
      padding: 0;
    }
    #nav-instruction {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.18em;
      font-weight: 600;
      color: #fff;
      margin: 14px 0 10px 0;
      letter-spacing: 0.01em;
      min-height: 38px;
      border-radius: 12px;
      background: var(--accent);
      box-shadow: 0 2px 8px var(--primary);
      padding: 7px 0 7px 0;
      transition: background 0.3s, color 0.3s;
      gap: 10px;
      user-select: none;
      min-width: 120px;
      max-width: 100vw;
      animation: fadeInNav 0.7s;
    }
    @keyframes fadeInNav {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .nav-icon {
      font-size: 1.5em;
      margin-right: 2px;
      filter: drop-shadow(0 1px 2px var(--accent));
      transition: transform 0.2s;
    }
    #marker-size-slider {
      width: 120px;
      accent-color: var(--accent);
      margin: 0 8px;
      vertical-align: middle;
      border-radius: 8px;
      background: var(--icon-bg);
      box-shadow: 0 1px 4px var(--primary);
      height: 4px;
      outline: none;
      transition: box-shadow 0.2s;
    }
    #marker-size-slider:active {
      box-shadow: 0 2px 8px var(--accent);
    }
    #status {
      font-size: 1em;
      color: var(--text-muted);
      margin-top: 12px;
      letter-spacing: 0.01em;
    }
    input[type="file"] {
      margin: 8px 0 10px 0;
      font-size: 1em;
      border-radius: 8px;
      border: 1.5px solid var(--glass-border);
      padding: 6px 10px;
      background: var(--icon-bg);
      color: var(--text);
      box-shadow: 0 1px 4px var(--primary);
      transition: border 0.2s;
    }
    input[type="file"]:focus {
      border: 1.5px solid var(--accent);
    }
    @media (max-width: 700px) {
      .main-layout {
        flex-direction: column;
        gap: 10px;
        padding: 0 2vw 0 2vw;
      }
      .map-area {
        max-width: 100vw;
        min-width: 0;
        padding: 10px 2vw 8px 2vw;
      }
      #container {
        min-height: 180px;
        height: 48vw;
      }
      #nav-instruction {
        font-size: 1em;
        min-height: 32px;
        padding: 5px 0;
      }
      #marker-size-slider {
        width: 80px;
      }
    }
  </style>
</head>
<body>
  <header>
    <div class="app-title">
      <span>üó∫Ô∏è</span>
      <span>Pathix</span>
    </div>
    <div class="subtitle">Navigate your property map in style</div>
  </header>
  <div class="main-layout">
    <div class="map-area glass-card">
      <div class="map-canvas-card">
        <div id="container"></div>
      </div>
      <div id="nav-instruction"></div>
      <div style="margin: 18px 0 0 0; width:100%; display:flex; flex-wrap:wrap; align-items:center; gap:12px; justify-content:center;">
        <input type="file" id="map-upload" accept="application/json" />
        <label for="marker-size-slider" style="font-size:1em;">Marker Size:</label>
        <input type="range" id="marker-size-slider" min="6" max="40" value="12" style="vertical-align:middle;">
        <span id="marker-size-value">12</span> px
      </div>
      <p id="status" style="margin-top:18px;">Waiting for GPS...</p>
    </div>
  </div>
  <footer style="text-align:center; color:var(--text-muted); font-size:0.98em; margin-bottom:18px; margin-top:10px;">
    &copy; 2024 Pathix &mdash; Crafted with <span style="color:var(--accent);">&#10084;&#65039;</span>
  </footer>
  <script>
    // --- Paste your exported map data here ---
    // Example structure:
    const mapData = {
      gpsOrigin: { lat: 28.6139, lng: 77.2090 }, // Set this to your map's origin
      gpsScale: 10000, // Set this to your map's scale
      roads: [
        // Each road: { points: [ {lat, lng}, ... ] }
        // Example: { points: [ {lat: 28.6139, lng: 77.2090}, {lat: 28.6140, lng: 77.2091} ] }
      ],
      landmarks: [
        // Each landmark: { type: 'house', lat, lng }
      ],
      route: [
        // Example: { lat: 28.6139, lng: 77.2090 }, { lat: 28.6141, lng: 77.2092 }, ...
      ]
    };
    // --- End map data ---

    // Emoji for landmarks
    const landmarkEmojis = {
      house: 'üè†',
      tree: 'üå≥',
    };

    // Konva setup
    function getContainerSize() {
      const container = document.getElementById('container');
      return {
        width: container.clientWidth,
        height: container.clientHeight
      };
    }

    let { width, height } = getContainerSize();
    const stage = new Konva.Stage({
      container: 'container',
      width,
      height,
    });
    const backgroundLayer = new Konva.Layer();
    const roadLayer = new Konva.Layer();
    const landmarkLayer = new Konva.Layer();
    const userLayer = new Konva.Layer();
    const routeLayer = new Konva.Layer();
    stage.add(backgroundLayer);
    stage.add(roadLayer);
    stage.add(landmarkLayer);
    stage.add(userLayer);
    stage.add(routeLayer);

    // Draw background
    let bgRect = new Konva.Rect({
      x: 0, y: 0, width, height, fill: '#e0e7ff'
    });
    backgroundLayer.add(bgRect);
    backgroundLayer.draw();

    // Helper: lat/lng to canvas
    function latLngToCanvas(lat, lng) {
      const { gpsOrigin, gpsScale } = mapData;
      if (!gpsOrigin) return {x: width/2, y: height/2};
      const x = width/2 + (lng - gpsOrigin.lng) * gpsScale;
      const y = height/2 - (lat - gpsOrigin.lat) * gpsScale;
      return {x, y};
    }

    // Draw roads
    const baseRoadWidth = 8;
    function drawRoads() {
      roadLayer.destroyChildren();
      mapData.roads.forEach(road => {
        if (road.points.length < 2) return;
        const points = road.points.map(pt => {
          const c = latLngToCanvas(pt.lat, pt.lng);
          return [c.x, c.y];
        }).flat();
        const line = new Konva.Line({
          points,
          stroke: '#374151',
          strokeWidth: baseRoadWidth / stage.scaleX(),
          lineCap: 'round',
          lineJoin: 'round',
        });
        roadLayer.add(line);
      });
      roadLayer.draw();
    }
    drawRoads();

    // Draw landmarks
    mapData.landmarks.forEach(lm => {
      const c = latLngToCanvas(lm.lat, lm.lng);
      const text = new Konva.Text({
        x: c.x - 16,
        y: c.y - 16,
        text: landmarkEmojis[lm.type] || '‚ùì',
        fontSize: 32,
        shadowColor: '#000',
        shadowBlur: 4,
        shadowOffset: { x: 2, y: 2 },
        shadowOpacity: 0.3,
      });
      landmarkLayer.add(text);
    });
    landmarkLayer.draw();

    // User marker
    let baseMarkerRadius = 12;
    const userMarker = new Konva.Circle({
      x: width/2, y: height/2, radius: baseMarkerRadius, fill: '#1d4ed8', stroke: '#fff', strokeWidth: 3, visible: false
    });
    userLayer.add(userMarker);
    userLayer.draw();

    // Draw route if present
    const baseRouteWidth = 5;
    function drawRoute() {
      routeLayer.destroyChildren();
      if (Array.isArray(mapData.route) && mapData.route.length > 1) {
        const points = mapData.route.map(pt => {
          const c = latLngToCanvas(pt.lat, pt.lng);
          return [c.x, c.y];
        }).flat();
        const line = new Konva.Line({
          points,
          stroke: '#f59e42',
          strokeWidth: baseRouteWidth / stage.scaleX(),
          lineCap: 'round',
          lineJoin: 'round',
          dash: [10, 8],
        });
        routeLayer.add(line);
        routeLayer.draw();
      }
    }
    drawRoute();

    // Track user position
    function updateUserMarker(lat, lng) {
      const c = latLngToCanvas(lat, lng);
      userMarker.x(c.x);
      userMarker.y(c.y);
      userMarker.visible(true);
      userLayer.batchDraw();
      updateNavigation(lat, lng);
    }

    if (navigator.geolocation) {
      navigator.geolocation.watchPosition(function(pos) {
        const { latitude: lat, longitude: lng } = pos.coords;
        updateUserMarker(lat, lng);
        document.getElementById('status').textContent = `Your position: ${lat.toFixed(5)}, ${lng.toFixed(5)}`;
      }, function(err) {
        document.getElementById('status').textContent = 'Unable to get your position: ' + err.message;
      }, {
        enableHighAccuracy: true,
        maximumAge: 0,
        timeout: 10000
      });
    } else {
      document.getElementById('status').textContent = 'Geolocation is not supported by your browser.';
    }

    // --- Map Upload Functionality ---
    document.getElementById('map-upload').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(evt) {
        try {
          const data = JSON.parse(evt.target.result);
          if (!data.gpsOrigin || !data.gpsScale || !Array.isArray(data.roads) || !Array.isArray(data.landmarks)) {
            throw new Error('Invalid map data format.');
          }
          // Remove old map
          roadLayer.destroyChildren();
          landmarkLayer.destroyChildren();
          routeLayer.destroyChildren();
          // Update mapData
          mapData.gpsOrigin = data.gpsOrigin;
          mapData.gpsScale = data.gpsScale;
          mapData.roads = data.roads;
          mapData.landmarks = data.landmarks;
          mapData.route = data.route || [];
          // Redraw roads
          drawRoads();
          // Redraw landmarks
          mapData.landmarks.forEach(lm => {
            const c = latLngToCanvas(lm.lat, lm.lng);
            const text = new Konva.Text({
              x: c.x - 16,
              y: c.y - 16,
              text: landmarkEmojis[lm.type] || '‚ùì',
              fontSize: 32,
              shadowColor: '#000',
              shadowBlur: 4,
              shadowOffset: { x: 2, y: 2 },
              shadowOpacity: 0.3,
            });
            landmarkLayer.add(text);
          });
          landmarkLayer.draw();
          // Redraw route
          drawRoute();
        } catch (err) {
          alert('Failed to load map: ' + err.message);
        }
      };
      reader.readAsText(file);
    });

    // --- Enable Zoom and Pan ---
    let scaleBy = 1.1;
    let minScale = 0.5;
    let maxScale = 4;

    // Zoom with mouse wheel
    stage.container().addEventListener('wheel', (e) => {
      e.preventDefault();
      const oldScale = stage.scaleX();
      const pointer = stage.getPointerPosition();

      let direction = e.deltaY > 0 ? -1 : 1;
      let newScale = direction > 0 ? oldScale * scaleBy : oldScale / scaleBy;
      newScale = Math.max(minScale, Math.min(maxScale, newScale));

      // Calculate new position to keep pointer under mouse
      const mousePointTo = {
        x: (pointer.x - stage.x()) / oldScale,
        y: (pointer.y - stage.y()) / oldScale,
      };

      stage.scale({ x: newScale, y: newScale });

      const newPos = {
        x: pointer.x - mousePointTo.x * newScale,
        y: pointer.y - mousePointTo.y * newScale,
      };
      stage.position(newPos);
      stage.batchDraw();
      updateScales();
    });

    // Pan with drag
    let lastDist = null;
    let lastCenter = null;

    stage.on('mousedown touchstart', (e) => {
      if (e.evt.touches && e.evt.touches.length === 2) {
        // Pinch start
        const [touch1, touch2] = e.evt.touches;
        lastDist = Math.hypot(
          touch1.clientX - touch2.clientX,
          touch1.clientY - touch2.clientY
        );
        lastCenter = {
          x: (touch1.clientX + touch2.clientX) / 2,
          y: (touch1.clientY + touch2.clientY) / 2,
        };
      } else {
        stage.draggable(true);
      }
    });

    stage.on('mouseup touchend', (e) => {
      stage.draggable(false);
      lastDist = null;
      lastCenter = null;
    });

    stage.on('touchmove', (e) => {
      if (e.evt.touches && e.evt.touches.length === 2) {
        // Pinch zoom
        const [touch1, touch2] = e.evt.touches;
        const dist = Math.hypot(
          touch1.clientX - touch2.clientX,
          touch1.clientY - touch2.clientY
        );
        const center = {
          x: (touch1.clientX + touch2.clientX) / 2,
          y: (touch1.clientY + touch2.clientY) / 2,
        };
        if (lastDist && lastCenter) {
          let scale = stage.scaleX() * (dist / lastDist);
          scale = Math.max(minScale, Math.min(maxScale, scale));
          stage.scale({ x: scale, y: scale });

          // Adjust position to keep center under fingers
          const dx = center.x - lastCenter.x;
          const dy = center.y - lastCenter.y;
          stage.position({
            x: stage.x() + dx,
            y: stage.y() + dy,
          });
          stage.batchDraw();
          updateScales();
        }
        lastDist = dist;
        lastCenter = center;
      }
    });

    // --- Navigation Suggestion Logic ---
    function getDistance(a, b) {
      // Approximate, for small distances
      const dx = (a.lat - b.lat) * 111320;
      const dy = (a.lng - b.lng) * 40075000 * Math.cos((a.lat + b.lat) * Math.PI / 360) / 360;
      return Math.sqrt(dx*dx + dy*dy);
    }
    function getHeading(a, b) {
      // Returns angle in degrees from north
      const dLon = (b.lng - a.lng) * Math.PI / 180;
      const y = Math.sin(dLon) * Math.cos(b.lat * Math.PI / 180);
      const x = Math.cos(a.lat * Math.PI / 180) * Math.sin(b.lat * Math.PI / 180) -
                Math.sin(a.lat * Math.PI / 180) * Math.cos(b.lat * Math.PI / 180) * Math.cos(dLon);
      let brng = Math.atan2(y, x) * 180 / Math.PI;
      return (brng + 360) % 360;
    }
    function getTurnInstruction(userPos, prevPos, route) {
      if (!route || route.length < 2) return '';
      // Find closest segment
      let minDist = Infinity, segIdx = 0;
      for (let i = 0; i < route.length - 1; i++) {
        const dist = getDistance(userPos, route[i]);
        if (dist < minDist) {
          minDist = dist;
          segIdx = i;
        }
      }
      // Heading of route segment
      const segA = route[segIdx];
      const segB = route[segIdx + 1] || segA;
      const routeHeading = getHeading(segA, segB);
      // User movement heading
      let userHeading = null;
      if (prevPos) userHeading = getHeading(prevPos, userPos);
      // Compare headings
      if (userHeading !== null) {
        let diff = (routeHeading - userHeading + 540) % 360 - 180;
        if (Math.abs(diff) < 25) return 'Go straight';
        if (diff > 25) return 'Turn right';
        if (diff < -25) return 'Turn left';
      }
      return 'Follow the route';
    }
    let prevUserPos = null;
    function updateNavigation(userLat, userLng) {
      const route = mapData.route;
      const navDiv = document.getElementById('nav-instruction');
      if (!route || route.length < 2) {
        navDiv.innerHTML = '';
        return;
      }
      const userPos = { lat: userLat, lng: userLng };
      const instruction = getTurnInstruction(userPos, prevUserPos, route);
      let icon = '';
      if (instruction === 'Go straight') icon = '<span class="nav-icon">‚¨ÜÔ∏è</span>';
      else if (instruction === 'Turn left') icon = '<span class="nav-icon">‚¨ÖÔ∏è</span>';
      else if (instruction === 'Turn right') icon = '<span class="nav-icon">‚û°Ô∏è</span>';
      else icon = '<span class="nav-icon">üß≠</span>';
      navDiv.innerHTML = icon + '<span>' + instruction + '</span>';
      prevUserPos = userPos;
    }

    // Update marker and road/route widths on zoom/pan
    function updateScales() {
      const scale = stage.scaleX();
      userMarker.radius(baseMarkerRadius / scale);
      // Update all road lines
      roadLayer.getChildren().forEach(line => {
        if (line.className === 'Line') line.strokeWidth(baseRoadWidth / scale);
      });
      // Update all route lines
      routeLayer.getChildren().forEach(line => {
        if (line.className === 'Line') line.strokeWidth(baseRouteWidth / scale);
      });
      roadLayer.batchDraw();
      routeLayer.batchDraw();
      userLayer.batchDraw();
    }

    // Marker size slider logic
    const markerSizeSlider = document.getElementById('marker-size-slider');
    const markerSizeValue = document.getElementById('marker-size-value');
    markerSizeSlider.addEventListener('input', function() {
      baseMarkerRadius = parseInt(this.value, 10);
      markerSizeValue.textContent = baseMarkerRadius;
      updateScales();
    });

    // Responsive resize logic
    function resizeStage() {
      const size = getContainerSize();
      width = size.width;
      height = size.height;
      stage.width(width);
      stage.height(height);
      bgRect.width(width);
      bgRect.height(height);
      backgroundLayer.batchDraw();
      drawRoads();
      drawRoute();
      // Redraw landmarks
      landmarkLayer.destroyChildren();
      mapData.landmarks.forEach(lm => {
        const c = latLngToCanvas(lm.lat, lm.lng);
        const text = new Konva.Text({
          x: c.x - 16,
          y: c.y - 16,
          text: landmarkEmojis[lm.type] || '‚ùì',
          fontSize: 32,
          shadowColor: '#000',
          shadowBlur: 4,
          shadowOffset: { x: 2, y: 2 },
          shadowOpacity: 0.3,
        });
        landmarkLayer.add(text);
      });
      landmarkLayer.batchDraw();
      updateScales();
    }

    window.addEventListener('resize', resizeStage);
    // Initial resize to fit container
    setTimeout(resizeStage, 0);
  </script>
</body>
</html> 